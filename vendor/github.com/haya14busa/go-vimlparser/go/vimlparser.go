// Code generated by gocompiler.vim
// source: autoload/vimlparser.vim
// DO NOT EDIT!

package vimlparser

var NODE_TOPLEVEL = 1
var NODE_COMMENT = 2
var NODE_EXCMD = 3
var NODE_FUNCTION = 4
var NODE_ENDFUNCTION = 5
var NODE_DELFUNCTION = 6
var NODE_RETURN = 7
var NODE_EXCALL = 8
var NODE_LET = 9
var NODE_UNLET = 10
var NODE_LOCKVAR = 11
var NODE_UNLOCKVAR = 12
var NODE_IF = 13
var NODE_ELSEIF = 14
var NODE_ELSE = 15
var NODE_ENDIF = 16
var NODE_WHILE = 17
var NODE_ENDWHILE = 18
var NODE_FOR = 19
var NODE_ENDFOR = 20
var NODE_CONTINUE = 21
var NODE_BREAK = 22
var NODE_TRY = 23
var NODE_CATCH = 24
var NODE_FINALLY = 25
var NODE_ENDTRY = 26
var NODE_THROW = 27
var NODE_ECHO = 28
var NODE_ECHON = 29
var NODE_ECHOHL = 30
var NODE_ECHOMSG = 31
var NODE_ECHOERR = 32
var NODE_EXECUTE = 33
var NODE_TERNARY = 34
var NODE_OR = 35
var NODE_AND = 36
var NODE_EQUAL = 37
var NODE_EQUALCI = 38
var NODE_EQUALCS = 39
var NODE_NEQUAL = 40
var NODE_NEQUALCI = 41
var NODE_NEQUALCS = 42
var NODE_GREATER = 43
var NODE_GREATERCI = 44
var NODE_GREATERCS = 45
var NODE_GEQUAL = 46
var NODE_GEQUALCI = 47
var NODE_GEQUALCS = 48
var NODE_SMALLER = 49
var NODE_SMALLERCI = 50
var NODE_SMALLERCS = 51
var NODE_SEQUAL = 52
var NODE_SEQUALCI = 53
var NODE_SEQUALCS = 54
var NODE_MATCH = 55
var NODE_MATCHCI = 56
var NODE_MATCHCS = 57
var NODE_NOMATCH = 58
var NODE_NOMATCHCI = 59
var NODE_NOMATCHCS = 60
var NODE_IS = 61
var NODE_ISCI = 62
var NODE_ISCS = 63
var NODE_ISNOT = 64
var NODE_ISNOTCI = 65
var NODE_ISNOTCS = 66
var NODE_ADD = 67
var NODE_SUBTRACT = 68
var NODE_CONCAT = 69
var NODE_MULTIPLY = 70
var NODE_DIVIDE = 71
var NODE_REMAINDER = 72
var NODE_NOT = 73
var NODE_MINUS = 74
var NODE_PLUS = 75
var NODE_SUBSCRIPT = 76
var NODE_SLICE = 77
var NODE_CALL = 78
var NODE_DOT = 79
var NODE_NUMBER = 80
var NODE_STRING = 81
var NODE_LIST = 82
var NODE_DICT = 83
var NODE_OPTION = 85
var NODE_IDENTIFIER = 86
var NODE_CURLYNAME = 87
var NODE_ENV = 88
var NODE_REG = 89
var NODE_CURLYNAMEPART = 90
var NODE_CURLYNAMEEXPR = 91
var NODE_LAMBDA = 92
var NODE_PARENEXPR = 93
var TOKEN_EOF = 1
var TOKEN_EOL = 2
var TOKEN_SPACE = 3
var TOKEN_OROR = 4
var TOKEN_ANDAND = 5
var TOKEN_EQEQ = 6
var TOKEN_EQEQCI = 7
var TOKEN_EQEQCS = 8
var TOKEN_NEQ = 9
var TOKEN_NEQCI = 10
var TOKEN_NEQCS = 11
var TOKEN_GT = 12
var TOKEN_GTCI = 13
var TOKEN_GTCS = 14
var TOKEN_GTEQ = 15
var TOKEN_GTEQCI = 16
var TOKEN_GTEQCS = 17
var TOKEN_LT = 18
var TOKEN_LTCI = 19
var TOKEN_LTCS = 20
var TOKEN_LTEQ = 21
var TOKEN_LTEQCI = 22
var TOKEN_LTEQCS = 23
var TOKEN_MATCH = 24
var TOKEN_MATCHCI = 25
var TOKEN_MATCHCS = 26
var TOKEN_NOMATCH = 27
var TOKEN_NOMATCHCI = 28
var TOKEN_NOMATCHCS = 29
var TOKEN_IS = 30
var TOKEN_ISCI = 31
var TOKEN_ISCS = 32
var TOKEN_ISNOT = 33
var TOKEN_ISNOTCI = 34
var TOKEN_ISNOTCS = 35
var TOKEN_PLUS = 36
var TOKEN_MINUS = 37
var TOKEN_DOT = 38
var TOKEN_STAR = 39
var TOKEN_SLASH = 40
var TOKEN_PERCENT = 41
var TOKEN_NOT = 42
var TOKEN_QUESTION = 43
var TOKEN_COLON = 44
var TOKEN_POPEN = 45
var TOKEN_PCLOSE = 46
var TOKEN_SQOPEN = 47
var TOKEN_SQCLOSE = 48
var TOKEN_COPEN = 49
var TOKEN_CCLOSE = 50
var TOKEN_COMMA = 51
var TOKEN_NUMBER = 52
var TOKEN_SQUOTE = 53
var TOKEN_DQUOTE = 54
var TOKEN_OPTION = 55
var TOKEN_IDENTIFIER = 56
var TOKEN_ENV = 57
var TOKEN_REG = 58
var TOKEN_EQ = 59
var TOKEN_OR = 60
var TOKEN_SEMICOLON = 61
var TOKEN_BACKTICK = 62
var TOKEN_DOTDOTDOT = 63
var TOKEN_SHARP = 64
var TOKEN_ARROW = 65
var MAX_FUNC_ARGS = 20

func isalpha(c string) bool {
	return viml_eqregh(c, "^[A-Za-z]$")
}

func isalnum(c string) bool {
	return viml_eqregh(c, "^[0-9A-Za-z]$")
}

func isdigit(c string) bool {
	return viml_eqregh(c, "^[0-9]$")
}

func isodigit(c string) bool {
	return viml_eqregh(c, "^[0-7]$")
}

func isxdigit(c string) bool {
	return viml_eqregh(c, "^[0-9A-Fa-f]$")
}

func iswordc(c string) bool {
	return viml_eqregh(c, "^[0-9A-Za-z_]$")
}

func iswordc1(c string) bool {
	return viml_eqregh(c, "^[A-Za-z_]$")
}

func iswhite(c string) bool {
	return viml_eqregh(c, "^[ \\t]$")
}

func isnamec(c string) bool {
	return viml_eqregh(c, "^[0-9A-Za-z_:#]$")
}

func isnamec1(c string) bool {
	return viml_eqregh(c, "^[A-Za-z_]$")
}

func isargname(s string) bool {
	return viml_eqregh(s, "^[A-Za-z_][0-9A-Za-z_]*$")
}

func isvarname(s string) bool {
	return viml_eqregh(s, "^[vgslabwt]:$\\|^\\([vgslabwt]:\\)\\?[A-Za-z_][0-9A-Za-z_#]*$")
}

// FIXME:
func isidc(c string) bool {
	return viml_eqregh(c, "^[0-9A-Za-z_]$")
}

func isupper(c string) bool {
	return viml_eqregh(c, "^[A-Z]$")
}

func islower(c string) bool {
	return viml_eqregh(c, "^[a-z]$")
}

// struct node {
//   int     type
//   pos     pos
//   node    left
//   node    right
//   node    cond
//   node    rest
//   node[]  list
//   node[]  rlist
//   node[]  body
//   string  op
//   string  str
//   int     depth
//   variant value
// }
// TOPLEVEL .body
// COMMENT .str
// EXCMD .ea .str
// FUNCTION .ea .body .left .rlist .attr .endfunction
// ENDFUNCTION .ea
// DELFUNCTION .ea .left
// RETURN .ea .left
// EXCALL .ea .left
// LET .ea .op .left .list .rest .right
// UNLET .ea .list
// LOCKVAR .ea .depth .list
// UNLOCKVAR .ea .depth .list
// IF .ea .body .cond .elseif .else .endif
// ELSEIF .ea .body .cond
// ELSE .ea .body
// ENDIF .ea
// WHILE .ea .body .cond .endwhile
// ENDWHILE .ea
// FOR .ea .body .left .list .rest .right .endfor
// ENDFOR .ea
// CONTINUE .ea
// BREAK .ea
// TRY .ea .body .catch .finally .endtry
// CATCH .ea .body .pattern
// FINALLY .ea .body
// ENDTRY .ea
// THROW .ea .left
// ECHO .ea .list
// ECHON .ea .list
// ECHOHL .ea .str
// ECHOMSG .ea .list
// ECHOERR .ea .list
// EXECUTE .ea .list
// TERNARY .cond .left .right
// OR .left .right
// AND .left .right
// EQUAL .left .right
// EQUALCI .left .right
// EQUALCS .left .right
// NEQUAL .left .right
// NEQUALCI .left .right
// NEQUALCS .left .right
// GREATER .left .right
// GREATERCI .left .right
// GREATERCS .left .right
// GEQUAL .left .right
// GEQUALCI .left .right
// GEQUALCS .left .right
// SMALLER .left .right
// SMALLERCI .left .right
// SMALLERCS .left .right
// SEQUAL .left .right
// SEQUALCI .left .right
// SEQUALCS .left .right
// MATCH .left .right
// MATCHCI .left .right
// MATCHCS .left .right
// NOMATCH .left .right
// NOMATCHCI .left .right
// NOMATCHCS .left .right
// IS .left .right
// ISCI .left .right
// ISCS .left .right
// ISNOT .left .right
// ISNOTCI .left .right
// ISNOTCS .left .right
// ADD .left .right
// SUBTRACT .left .right
// CONCAT .left .right
// MULTIPLY .left .right
// DIVIDE .left .right
// REMAINDER .left .right
// NOT .left
// MINUS .left
// PLUS .left
// SUBSCRIPT .left .right
// SLICE .left .rlist
// CALL .left .rlist
// DOT .left .right
// NUMBER .value
// STRING .value
// LIST .value
// DICT .value
// NESTING .left
// OPTION .value
// IDENTIFIER .value
// CURLYNAME .value
// ENV .value
// REG .value
// CURLYNAMEPART .value
// CURLYNAMEEXPR .value
// LAMBDA .rlist .left
// PARENEXPR .value
func (self *VimLParser) find_context(type_ int) int {
	var i = 0
	for _, node := range self.context {
		if node.type_ == type_ {
			return i
		}
		i += 1
	}
	return -1
}

func (self *VimLParser) add_node(node *VimNode) {
	self.context[0].body = append(self.context[0].body, node)
}

func (self *VimLParser) check_missing_endfunction(ends string, pos *pos) {
	if self.context[0].type_ == NODE_FUNCTION {
		panic(Err(viml_printf("E126: Missing :endfunction:    %s", ends), pos))
	}
}

func (self *VimLParser) check_missing_endif(ends string, pos *pos) {
	if self.context[0].type_ == NODE_IF || self.context[0].type_ == NODE_ELSEIF || self.context[0].type_ == NODE_ELSE {
		panic(Err(viml_printf("E171: Missing :endif:    %s", ends), pos))
	}
}

func (self *VimLParser) check_missing_endtry(ends string, pos *pos) {
	if self.context[0].type_ == NODE_TRY || self.context[0].type_ == NODE_CATCH || self.context[0].type_ == NODE_FINALLY {
		panic(Err(viml_printf("E600: Missing :endtry:    %s", ends), pos))
	}
}

func (self *VimLParser) check_missing_endwhile(ends string, pos *pos) {
	if self.context[0].type_ == NODE_WHILE {
		panic(Err(viml_printf("E170: Missing :endwhile:    %s", ends), pos))
	}
}

func (self *VimLParser) check_missing_endfor(ends string, pos *pos) {
	if self.context[0].type_ == NODE_FOR {
		panic(Err(viml_printf("E170: Missing :endfor:    %s", ends), pos))
	}
}

func (self *VimLParser) parse(reader *StringReader) *VimNode {
	self.reader = reader
	var toplevel = Node(NODE_TOPLEVEL)
	self.push_context(toplevel)
	for self.reader.peek() != "<EOF>" {
		self.parse_one_cmd()
	}
	self.check_missing_endfunction("TOPLEVEL", self.reader.getpos())
	self.check_missing_endif("TOPLEVEL", self.reader.getpos())
	self.check_missing_endtry("TOPLEVEL", self.reader.getpos())
	self.check_missing_endwhile("TOPLEVEL", self.reader.getpos())
	self.check_missing_endfor("TOPLEVEL", self.reader.getpos())
	self.pop_context()
	return toplevel
}

func (self *VimLParser) parse_one_cmd() {
	self.ea = &ExArg{}
	if self.reader.peekn(2) == "#!" {
		self.parse_hashbang()
		self.reader.get()
		return
	}
	self.reader.skip_white_and_colon()
	if self.reader.peekn(1) == "" {
		self.reader.get()
		return
	}
	if self.reader.peekn(1) == "\"" {
		self.parse_comment()
		self.reader.get()
		return
	}
	self.ea.linepos = self.reader.getpos()
	self.parse_command_modifiers()
	self.parse_range()
	self.parse_command()
	self.parse_trail()
}

// FIXME:
func (self *VimLParser) parse_command_modifiers() {
	var modifiers = []interface{}{}
	for true {
		var pos = self.reader.tell()
		var d = ""
		if isdigit(self.reader.peekn(1)) {
			d = self.reader.read_digit()
			self.reader.skip_white()
		}
		var k = self.reader.read_alpha()
		var c = self.reader.peekn(1)
		self.reader.skip_white()
		if viml_stridx("aboveleft", k) == 0 && len(k) >= 3 {
			// abo\%[veleft]
			modifiers = append(modifiers, map[string]interface{}{"name": "aboveleft"})
		} else if viml_stridx("belowright", k) == 0 && len(k) >= 3 {
			// bel\%[owright]
			modifiers = append(modifiers, map[string]interface{}{"name": "belowright"})
		} else if viml_stridx("browse", k) == 0 && len(k) >= 3 {
			// bro\%[wse]
			modifiers = append(modifiers, map[string]interface{}{"name": "browse"})
		} else if viml_stridx("botright", k) == 0 && len(k) >= 2 {
			// bo\%[tright]
			modifiers = append(modifiers, map[string]interface{}{"name": "botright"})
		} else if viml_stridx("confirm", k) == 0 && len(k) >= 4 {
			// conf\%[irm]
			modifiers = append(modifiers, map[string]interface{}{"name": "confirm"})
		} else if viml_stridx("keepmarks", k) == 0 && len(k) >= 3 {
			// kee\%[pmarks]
			modifiers = append(modifiers, map[string]interface{}{"name": "keepmarks"})
		} else if viml_stridx("keepalt", k) == 0 && len(k) >= 5 {
			// keepa\%[lt]
			modifiers = append(modifiers, map[string]interface{}{"name": "keepalt"})
		} else if viml_stridx("keepjumps", k) == 0 && len(k) >= 5 {
			// keepj\%[umps]
			modifiers = append(modifiers, map[string]interface{}{"name": "keepjumps"})
		} else if viml_stridx("keeppatterns", k) == 0 && len(k) >= 5 {
			// keepp\%[atterns]
			modifiers = append(modifiers, map[string]interface{}{"name": "keeppatterns"})
		} else if viml_stridx("hide", k) == 0 && len(k) >= 3 {
			//hid\%[e]
			if self.ends_excmds(c) {
				break
			}
			modifiers = append(modifiers, map[string]interface{}{"name": "hide"})
		} else if viml_stridx("lockmarks", k) == 0 && len(k) >= 3 {
			// loc\%[kmarks]
			modifiers = append(modifiers, map[string]interface{}{"name": "lockmarks"})
		} else if viml_stridx("leftabove", k) == 0 && len(k) >= 5 {
			// lefta\%[bove]
			modifiers = append(modifiers, map[string]interface{}{"name": "leftabove"})
		} else if viml_stridx("noautocmd", k) == 0 && len(k) >= 3 {
			// noa\%[utocmd]
			modifiers = append(modifiers, map[string]interface{}{"name": "noautocmd"})
		} else if viml_stridx("noswapfile", k) == 0 && len(k) >= 3 {
			// :nos\%[wapfile]
			modifiers = append(modifiers, map[string]interface{}{"name": "noswapfile"})
		} else if viml_stridx("rightbelow", k) == 0 && len(k) >= 6 {
			//rightb\%[elow]
			modifiers = append(modifiers, map[string]interface{}{"name": "rightbelow"})
		} else if viml_stridx("sandbox", k) == 0 && len(k) >= 3 {
			// san\%[dbox]
			modifiers = append(modifiers, map[string]interface{}{"name": "sandbox"})
		} else if viml_stridx("silent", k) == 0 && len(k) >= 3 {
			// sil\%[ent]
			if c == "!" {
				self.reader.get()
				modifiers = append(modifiers, map[string]interface{}{"name": "silent", "bang": 1})
			} else {
				modifiers = append(modifiers, map[string]interface{}{"name": "silent", "bang": 0})
			}
		} else if k == "tab" {
			// tab
			if d != "" {
				modifiers = append(modifiers, map[string]interface{}{"name": "tab", "count": viml_str2nr(d, 10)})
			} else {
				modifiers = append(modifiers, map[string]interface{}{"name": "tab"})
			}
		} else if viml_stridx("topleft", k) == 0 && len(k) >= 2 {
			// to\%[pleft]
			modifiers = append(modifiers, map[string]interface{}{"name": "topleft"})
		} else if viml_stridx("unsilent", k) == 0 && len(k) >= 3 {
			// uns\%[ilent]
			modifiers = append(modifiers, map[string]interface{}{"name": "unsilent"})
		} else if viml_stridx("vertical", k) == 0 && len(k) >= 4 {
			// vert\%[ical]
			modifiers = append(modifiers, map[string]interface{}{"name": "vertical"})
		} else if viml_stridx("verbose", k) == 0 && len(k) >= 4 {
			// verb\%[ose]
			if d != "" {
				modifiers = append(modifiers, map[string]interface{}{"name": "verbose", "count": viml_str2nr(d, 10)})
			} else {
				modifiers = append(modifiers, map[string]interface{}{"name": "verbose", "count": 1})
			}
		} else {
			self.reader.seek_set(pos)
			break
		}
	}
	self.ea.modifiers = modifiers
}

// FIXME:
func (self *VimLParser) parse_range() {
	var tokens = []interface{}{}
	for true {
		for true {
			self.reader.skip_white()
			var c = self.reader.peekn(1)
			if c == "" {
				break
			}
			if c == "." {
				tokens = append(tokens, self.reader.getn(1))
			} else if c == "$" {
				tokens = append(tokens, self.reader.getn(1))
			} else if c == "'" {
				self.reader.getn(1)
				var m = self.reader.getn(1)
				if m == "" {
					break
				}
				tokens = append(tokens, "'"+m)
			} else if c == "/" {
				self.reader.getn(1)
				var pattern, _ = self.parse_pattern(c)
				tokens = append(tokens, pattern)
			} else if c == "?" {
				self.reader.getn(1)
				var pattern, _ = self.parse_pattern(c)
				tokens = append(tokens, pattern)
			} else if c == "\\" {
				var m = self.reader.p(1)
				if m == "&" || m == "?" || m == "/" {
					self.reader.seek_cur(2)
					tokens = append(tokens, "\\"+m)
				} else {
					panic(Err("E10: \\\\ should be followed by /, ? or &", self.reader.getpos()))
				}
			} else if isdigit(c) {
				tokens = append(tokens, self.reader.read_digit())
			}
			for true {
				self.reader.skip_white()
				if self.reader.peekn(1) == "" {
					break
				}
				var n = self.reader.read_integer()
				if n == "" {
					break
				}
				tokens = append(tokens, n)
			}
			if self.reader.p(0) != "/" && self.reader.p(0) != "?" {
				break
			}
		}
		if self.reader.peekn(1) == "%" {
			tokens = append(tokens, self.reader.getn(1))
		} else if self.reader.peekn(1) == "*" {
			// && &cpoptions !~ '\*'
			tokens = append(tokens, self.reader.getn(1))
		}
		if self.reader.peekn(1) == ";" {
			tokens = append(tokens, self.reader.getn(1))
			continue
		} else if self.reader.peekn(1) == "," {
			tokens = append(tokens, self.reader.getn(1))
			continue
		}
		break
	}
	self.ea.range_ = tokens
}

// FIXME:
func (self *VimLParser) parse_pattern(delimiter string) (string, string) {
	var pattern = ""
	var endc = ""
	var inbracket = 0
	for true {
		var c = self.reader.getn(1)
		if c == "" {
			break
		}
		if c == delimiter && inbracket == 0 {
			endc = c
			break
		}
		pattern += c
		if c == "\\" {
			c = self.reader.peekn(1)
			if c == "" {
				panic(Err("E682: Invalid search pattern or delimiter", self.reader.getpos()))
			}
			self.reader.getn(1)
			pattern += c
		} else if c == "[" {
			inbracket += 1
		} else if c == "]" {
			inbracket -= 1
		}
	}
	return pattern, endc
}

func (self *VimLParser) parse_command() {
	self.reader.skip_white_and_colon()
	self.ea.cmdpos = self.reader.getpos()
	if self.reader.peekn(1) == "" || self.reader.peekn(1) == "\"" {
		if !viml_empty(self.ea.modifiers) || !viml_empty(self.ea.range_) {
			self.parse_cmd_modifier_range()
		}
		return
	}
	self.ea.cmd = self.find_command()
	if self.ea.cmd == nil {
		self.reader.setpos(self.ea.cmdpos)
		panic(Err(viml_printf("E492: Not an editor command: %s", self.reader.peekline()), self.ea.cmdpos))
	}
	if self.reader.peekn(1) == "!" && self.ea.cmd.name != "substitute" && self.ea.cmd.name != "smagic" && self.ea.cmd.name != "snomagic" {
		self.reader.getn(1)
		self.ea.forceit = true
	} else {
		self.ea.forceit = false
	}
	if !viml_eqregh(self.ea.cmd.flags, "\\<BANG\\>") && self.ea.forceit && !viml_eqregh(self.ea.cmd.flags, "\\<USERCMD\\>") {
		panic(Err("E477: No ! allowed", self.ea.cmdpos))
	}
	if self.ea.cmd.name != "!" {
		self.reader.skip_white()
	}
	self.ea.argpos = self.reader.getpos()
	if viml_eqregh(self.ea.cmd.flags, "\\<ARGOPT\\>") {
		self.parse_argopt()
	}
	if self.ea.cmd.name == "write" || self.ea.cmd.name == "update" {
		if self.reader.p(0) == ">" {
			if self.reader.p(1) != ">" {
				panic(Err("E494: Use w or w>>", self.ea.cmdpos))
			}
			self.reader.seek_cur(2)
			self.reader.skip_white()
			self.ea.append = 1
		} else if self.reader.peekn(1) == "!" && self.ea.cmd.name == "write" {
			self.reader.getn(1)
			self.ea.usefilter = true
		}
	}
	if self.ea.cmd.name == "read" {
		if self.ea.forceit {
			self.ea.usefilter = true
			self.ea.forceit = false
		} else if self.reader.peekn(1) == "!" {
			self.reader.getn(1)
			self.ea.usefilter = true
		}
	}
	if self.ea.cmd.name == "<" || self.ea.cmd.name == ">" {
		self.ea.amount = 1
		for self.reader.peekn(1) == self.ea.cmd.name {
			self.reader.getn(1)
			self.ea.amount += 1
		}
		self.reader.skip_white()
	}
	if viml_eqregh(self.ea.cmd.flags, "\\<EDITCMD\\>") && !self.ea.usefilter {
		self.parse_argcmd()
	}
	self._parse_command(self.ea.cmd.parser)
}

func (self *VimLParser) _parse_command(parser string) {
	if parser == "parse_cmd_append" {
		self.parse_cmd_append()
	} else if parser == "parse_cmd_break" {
		self.parse_cmd_break()
	} else if parser == "parse_cmd_call" {
		self.parse_cmd_call()
	} else if parser == "parse_cmd_catch" {
		self.parse_cmd_catch()
	} else if parser == "parse_cmd_common" {
		self.parse_cmd_common()
	} else if parser == "parse_cmd_continue" {
		self.parse_cmd_continue()
	} else if parser == "parse_cmd_delfunction" {
		self.parse_cmd_delfunction()
	} else if parser == "parse_cmd_echo" {
		self.parse_cmd_echo()
	} else if parser == "parse_cmd_echoerr" {
		self.parse_cmd_echoerr()
	} else if parser == "parse_cmd_echohl" {
		self.parse_cmd_echohl()
	} else if parser == "parse_cmd_echomsg" {
		self.parse_cmd_echomsg()
	} else if parser == "parse_cmd_echon" {
		self.parse_cmd_echon()
	} else if parser == "parse_cmd_else" {
		self.parse_cmd_else()
	} else if parser == "parse_cmd_elseif" {
		self.parse_cmd_elseif()
	} else if parser == "parse_cmd_endfor" {
		self.parse_cmd_endfor()
	} else if parser == "parse_cmd_endfunction" {
		self.parse_cmd_endfunction()
	} else if parser == "parse_cmd_endif" {
		self.parse_cmd_endif()
	} else if parser == "parse_cmd_endtry" {
		self.parse_cmd_endtry()
	} else if parser == "parse_cmd_endwhile" {
		self.parse_cmd_endwhile()
	} else if parser == "parse_cmd_execute" {
		self.parse_cmd_execute()
	} else if parser == "parse_cmd_finally" {
		self.parse_cmd_finally()
	} else if parser == "parse_cmd_finish" {
		self.parse_cmd_finish()
	} else if parser == "parse_cmd_for" {
		self.parse_cmd_for()
	} else if parser == "parse_cmd_function" {
		self.parse_cmd_function()
	} else if parser == "parse_cmd_if" {
		self.parse_cmd_if()
	} else if parser == "parse_cmd_insert" {
		self.parse_cmd_insert()
	} else if parser == "parse_cmd_let" {
		self.parse_cmd_let()
	} else if parser == "parse_cmd_loadkeymap" {
		self.parse_cmd_loadkeymap()
	} else if parser == "parse_cmd_lockvar" {
		self.parse_cmd_lockvar()
	} else if parser == "parse_cmd_lua" {
		self.parse_cmd_lua()
	} else if parser == "parse_cmd_modifier_range" {
		self.parse_cmd_modifier_range()
	} else if parser == "parse_cmd_mzscheme" {
		self.parse_cmd_mzscheme()
	} else if parser == "parse_cmd_perl" {
		self.parse_cmd_perl()
	} else if parser == "parse_cmd_python" {
		self.parse_cmd_python()
	} else if parser == "parse_cmd_python3" {
		self.parse_cmd_python3()
	} else if parser == "parse_cmd_return" {
		self.parse_cmd_return()
	} else if parser == "parse_cmd_ruby" {
		self.parse_cmd_ruby()
	} else if parser == "parse_cmd_tcl" {
		self.parse_cmd_tcl()
	} else if parser == "parse_cmd_throw" {
		self.parse_cmd_throw()
	} else if parser == "parse_cmd_try" {
		self.parse_cmd_try()
	} else if parser == "parse_cmd_unlet" {
		self.parse_cmd_unlet()
	} else if parser == "parse_cmd_unlockvar" {
		self.parse_cmd_unlockvar()
	} else if parser == "parse_cmd_usercmd" {
		self.parse_cmd_usercmd()
	} else if parser == "parse_cmd_while" {
		self.parse_cmd_while()
	} else if parser == "parse_wincmd" {
		self.parse_wincmd()
	} else if parser == "parse_cmd_syntax" {
		self.parse_cmd_syntax()
	} else {
		panic(viml_printf("unknown parser: %s", viml_string(parser)))
	}
}

func (self *VimLParser) find_command() *Cmd {
	var c = self.reader.peekn(1)
	var name = ""
	if c == "k" {
		self.reader.getn(1)
		name = "k"
	} else if c == "s" && viml_eqregh(self.reader.peekn(5), "\\v^s%(c[^sr][^i][^p]|g|i[^mlg]|I|r[^e])") {
		self.reader.getn(1)
		name = "substitute"
	} else if viml_eqregh(c, "[@*!=><&~#]") {
		self.reader.getn(1)
		name = c
	} else if self.reader.peekn(2) == "py" {
		name = self.reader.read_alnum()
	} else {
		var pos = self.reader.tell()
		name = self.reader.read_alpha()
		if name != "del" && viml_eqregh(name, "\\v^d%[elete][lp]$") {
			self.reader.seek_set(pos)
			name = self.reader.getn(len(name) - 1)
		}
	}
	if name == "" {
		return nil
	}
	if viml_has_key(self.find_command_cache, name) {
		return self.find_command_cache[name]
	}
	var cmd *Cmd = nil
	for _, x := range builtin_commands {
		if viml_stridx(x.name, name) == 0 && len(name) >= x.minlen {
			cmd = x
			break
		}
	}
	if self.neovim {
		for _, x := range neovim_additional_commands {
			if viml_stridx(x.name, name) == 0 && len(name) >= x.minlen {
				cmd = x
				break
			}
		}
		for _, x := range neovim_removed_commands {
			if viml_stridx(x.name, name) == 0 && len(name) >= x.minlen {
				cmd = nil
				break
			}
		}
	}
	// FIXME: user defined command
	if (cmd == nil || cmd.name == "Print") && viml_eqregh(name, "^[A-Z]") {
		name += self.reader.read_alnum()
		cmd = &Cmd{name: name, flags: "USERCMD", parser: "parse_cmd_usercmd"}
	}
	self.find_command_cache[name] = cmd
	return cmd
}

// TODO:
func (self *VimLParser) parse_hashbang() {
	self.reader.getn(-1)
}

// TODO:
// ++opt=val
func (self *VimLParser) parse_argopt() {
	for self.reader.p(0) == "+" && self.reader.p(1) == "+" {
		var s = self.reader.peekn(20)
		if viml_eqregh(s, "^++bin\\>") {
			self.reader.getn(5)
			self.ea.force_bin = 1
		} else if viml_eqregh(s, "^++nobin\\>") {
			self.reader.getn(7)
			self.ea.force_bin = 2
		} else if viml_eqregh(s, "^++edit\\>") {
			self.reader.getn(6)
			self.ea.read_edit = 1
		} else if viml_eqregh(s, "^++ff=\\(dos\\|unix\\|mac\\)\\>") {
			self.reader.getn(5)
			self.ea.force_ff = self.reader.read_alpha()
		} else if viml_eqregh(s, "^++fileformat=\\(dos\\|unix\\|mac\\)\\>") {
			self.reader.getn(13)
			self.ea.force_ff = self.reader.read_alpha()
		} else if viml_eqregh(s, "^++enc=\\S") {
			self.reader.getn(6)
			self.ea.force_enc = self.reader.read_nonwhite()
		} else if viml_eqregh(s, "^++encoding=\\S") {
			self.reader.getn(11)
			self.ea.force_enc = self.reader.read_nonwhite()
		} else if viml_eqregh(s, "^++bad=\\(keep\\|drop\\|.\\)\\>") {
			self.reader.getn(6)
			if viml_eqregh(s, "^++bad=keep") {
				self.ea.bad_char = self.reader.getn(4)
			} else if viml_eqregh(s, "^++bad=drop") {
				self.ea.bad_char = self.reader.getn(4)
			} else {
				self.ea.bad_char = self.reader.getn(1)
			}
		} else if viml_eqregh(s, "^++") {
			panic(Err("E474: Invalid Argument", self.reader.getpos()))
		} else {
			break
		}
		self.reader.skip_white()
	}
}

// TODO:
// +command
func (self *VimLParser) parse_argcmd() {
	if self.reader.peekn(1) == "+" {
		self.reader.getn(1)
		if self.reader.peekn(1) == " " {
			self.ea.do_ecmd_cmd = "$"
		} else {
			self.ea.do_ecmd_cmd = self.read_cmdarg()
		}
	}
}

func (self *VimLParser) read_cmdarg() string {
	var r = ""
	for true {
		var c = self.reader.peekn(1)
		if c == "" || iswhite(c) {
			break
		}
		self.reader.getn(1)
		if c == "\\" {
			c = self.reader.getn(1)
		}
		r += c
	}
	return r
}

func (self *VimLParser) parse_comment() {
	var npos = self.reader.getpos()
	var c = self.reader.get()
	if c != "\"" {
		panic(Err(viml_printf("unexpected character: %s", c), npos))
	}
	var node = Node(NODE_COMMENT)
	node.pos = npos
	node.str = self.reader.getn(-1)
	self.add_node(node)
}

func (self *VimLParser) parse_trail() {
	self.reader.skip_white()
	var c = self.reader.peek()
	if c == "<EOF>" {
		// pass
	} else if c == "<EOL>" {
		self.reader.get()
	} else if c == "|" {
		self.reader.get()
	} else if c == "\"" {
		self.parse_comment()
		self.reader.get()
	} else {
		panic(Err(viml_printf("E488: Trailing characters: %s", c), self.reader.getpos()))
	}
}

// modifier or range only command line
func (self *VimLParser) parse_cmd_modifier_range() {
	var node = Node(NODE_EXCMD)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.str = self.reader.getstr(self.ea.linepos, self.reader.getpos())
	self.add_node(node)
}

// TODO:
func (self *VimLParser) parse_cmd_common() {
	var end = self.reader.getpos()
	if viml_eqregh(self.ea.cmd.flags, "\\<TRLBAR\\>") && !self.ea.usefilter {
		end = self.separate_nextcmd()
	} else if self.ea.cmd.name == "!" || self.ea.cmd.name == "global" || self.ea.cmd.name == "vglobal" || self.ea.usefilter {
		for true {
			end = self.reader.getpos()
			if self.reader.getn(1) == "" {
				break
			}
		}
	} else {
		for true {
			end = self.reader.getpos()
			if self.reader.getn(1) == "" {
				break
			}
		}
	}
	var node = Node(NODE_EXCMD)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.str = self.reader.getstr(self.ea.linepos, end)
	self.add_node(node)
}

func (self *VimLParser) separate_nextcmd() *pos {
	if self.ea.cmd.name == "vimgrep" || self.ea.cmd.name == "vimgrepadd" || self.ea.cmd.name == "lvimgrep" || self.ea.cmd.name == "lvimgrepadd" {
		self.skip_vimgrep_pat()
	}
	var pc = ""
	var end = self.reader.getpos()
	var nospend = end
	for true {
		end = self.reader.getpos()
		if !iswhite(pc) {
			nospend = end
		}
		var c = self.reader.peek()
		if c == "<EOF>" || c == "<EOL>" {
			break
		} else if c == "\x16" {
			// <C-V>
			self.reader.get()
			end = self.reader.getpos()
			nospend = self.reader.getpos()
			c = self.reader.peek()
			if c == "<EOF>" || c == "<EOL>" {
				break
			}
			self.reader.get()
		} else if self.reader.peekn(2) == "`=" && viml_eqregh(self.ea.cmd.flags, "\\<\\(XFILE\\|FILES\\|FILE1\\)\\>") {
			self.reader.getn(2)
			self.parse_expr()
			c = self.reader.peekn(1)
			if c != "`" {
				panic(Err(viml_printf("unexpected character: %s", c), self.reader.getpos()))
			}
			self.reader.getn(1)
		} else if c == "|" || c == "\n" || (c == "\"" && !viml_eqregh(self.ea.cmd.flags, "\\<NOTRLCOM\\>") && ((self.ea.cmd.name != "@" && self.ea.cmd.name != "*") || self.reader.getpos() != self.ea.argpos) && (self.ea.cmd.name != "redir" || self.reader.getpos().i != self.ea.argpos.i+1 || pc != "@")) {
			var has_cpo_bar = false
			// &cpoptions =~ 'b'
			if (!has_cpo_bar || !viml_eqregh(self.ea.cmd.flags, "\\<USECTRLV\\>")) && pc == "\\" {
				self.reader.get()
			} else {
				break
			}
		} else {
			self.reader.get()
		}
		pc = c
	}
	if !viml_eqregh(self.ea.cmd.flags, "\\<NOTRLCOM\\>") {
		end = nospend
	}
	return end
}

// FIXME
func (self *VimLParser) skip_vimgrep_pat() {
	if self.reader.peekn(1) == "" {
		// pass
	} else if isidc(self.reader.peekn(1)) {
		// :vimgrep pattern fname
		self.reader.read_nonwhite()
	} else {
		// :vimgrep /pattern/[g][j] fname
		var c = self.reader.getn(1)
		var _, endc = self.parse_pattern(c)
		if c != endc {
			return
		}
		for self.reader.p(0) == "g" || self.reader.p(0) == "j" {
			self.reader.getn(1)
		}
	}
}

func (self *VimLParser) parse_cmd_append() {
	self.reader.setpos(self.ea.linepos)
	var cmdline = self.reader.readline()
	var lines = []interface{}{cmdline}
	var m = "."
	for true {
		if self.reader.peek() == "<EOF>" {
			break
		}
		var line = self.reader.getn(-1)
		lines = append(lines, line)
		if line == m {
			break
		}
		self.reader.get()
	}
	var node = Node(NODE_EXCMD)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.str = viml_join(lines, "\n")
	self.add_node(node)
}

func (self *VimLParser) parse_cmd_insert() {
	self.parse_cmd_append()
}

func (self *VimLParser) parse_cmd_loadkeymap() {
	self.reader.setpos(self.ea.linepos)
	var cmdline = self.reader.readline()
	var lines = []interface{}{cmdline}
	for true {
		if self.reader.peek() == "<EOF>" {
			break
		}
		var line = self.reader.readline()
		lines = append(lines, line)
	}
	var node = Node(NODE_EXCMD)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.str = viml_join(lines, "\n")
	self.add_node(node)
}

func (self *VimLParser) parse_cmd_lua() {
	var lines = []interface{}{}
	self.reader.skip_white()
	if self.reader.peekn(2) == "<<" {
		self.reader.getn(2)
		self.reader.skip_white()
		var m = self.reader.readline()
		if m == "" {
			m = "."
		}
		self.reader.setpos(self.ea.linepos)
		var cmdline = self.reader.getn(-1)
		lines = []interface{}{cmdline}
		self.reader.get()
		for true {
			if self.reader.peek() == "<EOF>" {
				break
			}
			var line = self.reader.getn(-1)
			lines = append(lines, line)
			if line == m {
				break
			}
			self.reader.get()
		}
	} else {
		self.reader.setpos(self.ea.linepos)
		var cmdline = self.reader.getn(-1)
		lines = []interface{}{cmdline}
	}
	var node = Node(NODE_EXCMD)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.str = viml_join(lines, "\n")
	self.add_node(node)
}

func (self *VimLParser) parse_cmd_mzscheme() {
	self.parse_cmd_lua()
}

func (self *VimLParser) parse_cmd_perl() {
	self.parse_cmd_lua()
}

func (self *VimLParser) parse_cmd_python() {
	self.parse_cmd_lua()
}

func (self *VimLParser) parse_cmd_python3() {
	self.parse_cmd_lua()
}

func (self *VimLParser) parse_cmd_ruby() {
	self.parse_cmd_lua()
}

func (self *VimLParser) parse_cmd_tcl() {
	self.parse_cmd_lua()
}

func (self *VimLParser) parse_cmd_finish() {
	self.parse_cmd_common()
	if self.context[0].type_ == NODE_TOPLEVEL {
		self.reader.seek_end(0)
	}
}

// FIXME
func (self *VimLParser) parse_cmd_usercmd() {
	self.parse_cmd_common()
}

func (self *VimLParser) parse_cmd_function() {
	var pos = self.reader.tell()
	self.reader.skip_white()
	// :function
	if self.ends_excmds(self.reader.peek()) {
		self.reader.seek_set(pos)
		self.parse_cmd_common()
		return
	}
	// :function /pattern
	if self.reader.peekn(1) == "/" {
		self.reader.seek_set(pos)
		self.parse_cmd_common()
		return
	}
	var left = self.parse_lvalue_func()
	self.reader.skip_white()
	if left.type_ == NODE_IDENTIFIER {
		var s = left.value.(string)
		var ss = viml_split(s, "\\zs")
		if ss[0] != "<" && !isupper(ss[0]) && viml_stridx(s, ":") == -1 && viml_stridx(s, "#") == -1 {
			panic(Err(viml_printf("E128: Function name must start with a capital or contain a colon: %s", s), left.pos))
		}
	}
	// :function {name}
	if self.reader.peekn(1) != "(" {
		self.reader.seek_set(pos)
		self.parse_cmd_common()
		return
	}
	// :function[!] {name}([arguments]) [range] [abort] [dict] [closure]
	var node = Node(NODE_FUNCTION)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.left = left
	self.reader.getn(1)
	var tokenizer = NewExprTokenizer(self.reader)
	if tokenizer.peek().type_ == TOKEN_PCLOSE {
		tokenizer.get()
	} else {
		var named = map[string]interface{}{}
		for true {
			var varnode = Node(NODE_IDENTIFIER)
			var token = tokenizer.get()
			if token.type_ == TOKEN_IDENTIFIER {
				if !isargname(token.value) || token.value == "firstline" || token.value == "lastline" {
					panic(Err(viml_printf("E125: Illegal argument: %s", token.value), token.pos))
				} else if viml_has_key(named, token.value) {
					panic(Err(viml_printf("E853: Duplicate argument name: %s", token.value), token.pos))
				}
				named[token.value] = 1
				varnode.pos = token.pos
				varnode.value = token.value
				node.rlist = append(node.rlist, varnode)
				// XXX: Vim doesn't skip white space before comma.  F(a ,b) => E475
				if iswhite(self.reader.p(0)) && tokenizer.peek().type_ == TOKEN_COMMA {
					panic(Err("E475: Invalid argument: White space is not allowed before comma", self.reader.getpos()))
				}
				token = tokenizer.get()
				if token.type_ == TOKEN_COMMA {
					// XXX: Vim allows last comma.  F(a, b, ) => OK
					if tokenizer.peek().type_ == TOKEN_PCLOSE {
						tokenizer.get()
						break
					}
				} else if token.type_ == TOKEN_PCLOSE {
					break
				} else {
					panic(Err(viml_printf("unexpected token: %s", token.value), token.pos))
				}
			} else if token.type_ == TOKEN_DOTDOTDOT {
				varnode.pos = token.pos
				varnode.value = token.value
				node.rlist = append(node.rlist, varnode)
				token = tokenizer.get()
				if token.type_ == TOKEN_PCLOSE {
					break
				} else {
					panic(Err(viml_printf("unexpected token: %s", token.value), token.pos))
				}
			} else {
				panic(Err(viml_printf("unexpected token: %s", token.value), token.pos))
			}
		}
	}
	for true {
		self.reader.skip_white()
		var epos = self.reader.getpos()
		var key = self.reader.read_alpha()
		if key == "" {
			break
		} else if key == "range" {
			node.attr.range_ = true
		} else if key == "abort" {
			node.attr.abort = true
		} else if key == "dict" {
			node.attr.dict = true
		} else if key == "closure" {
			node.attr.closure = true
		} else {
			panic(Err(viml_printf("unexpected token: %s", key), epos))
		}
	}
	self.add_node(node)
	self.push_context(node)
}

func (self *VimLParser) parse_cmd_endfunction() {
	self.check_missing_endif("ENDFUNCTION", self.ea.cmdpos)
	self.check_missing_endtry("ENDFUNCTION", self.ea.cmdpos)
	self.check_missing_endwhile("ENDFUNCTION", self.ea.cmdpos)
	self.check_missing_endfor("ENDFUNCTION", self.ea.cmdpos)
	if self.context[0].type_ != NODE_FUNCTION {
		panic(Err("E193: :endfunction not inside a function", self.ea.cmdpos))
	}
	self.reader.getn(-1)
	var node = Node(NODE_ENDFUNCTION)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	self.context[0].endfunction = node
	self.pop_context()
}

func (self *VimLParser) parse_cmd_delfunction() {
	var node = Node(NODE_DELFUNCTION)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.left = self.parse_lvalue_func()
	self.add_node(node)
}

func (self *VimLParser) parse_cmd_return() {
	if self.find_context(NODE_FUNCTION) == -1 {
		panic(Err("E133: :return not inside a function", self.ea.cmdpos))
	}
	var node = Node(NODE_RETURN)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.left = nil
	self.reader.skip_white()
	var c = self.reader.peek()
	if c == "\"" || !self.ends_excmds(c) {
		node.left = self.parse_expr()
	}
	self.add_node(node)
}

func (self *VimLParser) parse_cmd_call() {
	var node = Node(NODE_EXCALL)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	self.reader.skip_white()
	var c = self.reader.peek()
	if self.ends_excmds(c) {
		panic(Err("E471: Argument required", self.reader.getpos()))
	}
	node.left = self.parse_expr()
	if node.left.type_ != NODE_CALL {
		panic(Err("Not an function call", node.left.pos))
	}
	self.add_node(node)
}

func (self *VimLParser) parse_cmd_let() {
	var pos = self.reader.tell()
	self.reader.skip_white()
	// :let
	if self.ends_excmds(self.reader.peek()) {
		self.reader.seek_set(pos)
		self.parse_cmd_common()
		return
	}
	var lhs = self.parse_letlhs()
	self.reader.skip_white()
	var s1 = self.reader.peekn(1)
	var s2 = self.reader.peekn(2)
	// :let {var-name} ..
	if self.ends_excmds(s1) || (s2 != "+=" && s2 != "-=" && s2 != ".=" && s1 != "=") {
		self.reader.seek_set(pos)
		self.parse_cmd_common()
		return
	}
	// :let left op right
	var node = Node(NODE_LET)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.op = ""
	node.left = lhs.left
	node.list = lhs.list
	node.rest = lhs.rest
	node.right = nil
	if s2 == "+=" || s2 == "-=" || s2 == ".=" {
		self.reader.getn(2)
		node.op = s2
	} else if s1 == "=" {
		self.reader.getn(1)
		node.op = s1
	} else {
		panic("NOT REACHED")
	}
	node.right = self.parse_expr()
	self.add_node(node)
}

func (self *VimLParser) parse_cmd_unlet() {
	var node = Node(NODE_UNLET)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.list = self.parse_lvaluelist()
	self.add_node(node)
}

func (self *VimLParser) parse_cmd_lockvar() {
	var node = Node(NODE_LOCKVAR)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	self.reader.skip_white()
	if isdigit(self.reader.peekn(1)) {
		node.depth = viml_str2nr(self.reader.read_digit(), 10)
	}
	node.list = self.parse_lvaluelist()
	self.add_node(node)
}

func (self *VimLParser) parse_cmd_unlockvar() {
	var node = Node(NODE_UNLOCKVAR)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	self.reader.skip_white()
	if isdigit(self.reader.peekn(1)) {
		node.depth = viml_str2nr(self.reader.read_digit(), 10)
	}
	node.list = self.parse_lvaluelist()
	self.add_node(node)
}

func (self *VimLParser) parse_cmd_if() {
	var node = Node(NODE_IF)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.cond = self.parse_expr()
	self.add_node(node)
	self.push_context(node)
}

func (self *VimLParser) parse_cmd_elseif() {
	if self.context[0].type_ != NODE_IF && self.context[0].type_ != NODE_ELSEIF {
		panic(Err("E582: :elseif without :if", self.ea.cmdpos))
	}
	if self.context[0].type_ != NODE_IF {
		self.pop_context()
	}
	var node = Node(NODE_ELSEIF)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.cond = self.parse_expr()
	self.context[0].elseif = append(self.context[0].elseif, node)
	self.push_context(node)
}

func (self *VimLParser) parse_cmd_else() {
	if self.context[0].type_ != NODE_IF && self.context[0].type_ != NODE_ELSEIF {
		panic(Err("E581: :else without :if", self.ea.cmdpos))
	}
	if self.context[0].type_ != NODE_IF {
		self.pop_context()
	}
	var node = Node(NODE_ELSE)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	self.context[0].else_ = node
	self.push_context(node)
}

func (self *VimLParser) parse_cmd_endif() {
	if self.context[0].type_ != NODE_IF && self.context[0].type_ != NODE_ELSEIF && self.context[0].type_ != NODE_ELSE {
		panic(Err("E580: :endif without :if", self.ea.cmdpos))
	}
	if self.context[0].type_ != NODE_IF {
		self.pop_context()
	}
	var node = Node(NODE_ENDIF)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	self.context[0].endif = node
	self.pop_context()
}

func (self *VimLParser) parse_cmd_while() {
	var node = Node(NODE_WHILE)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.cond = self.parse_expr()
	node.endwhile = nil
	self.add_node(node)
	self.push_context(node)
}

func (self *VimLParser) parse_cmd_endwhile() {
	if self.context[0].type_ != NODE_WHILE {
		panic(Err("E588: :endwhile without :while", self.ea.cmdpos))
	}
	var node = Node(NODE_ENDWHILE)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	self.context[0].endwhile = node
	self.pop_context()
}

func (self *VimLParser) parse_cmd_for() {
	var node = Node(NODE_FOR)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.left = nil
	node.right = nil
	var lhs = self.parse_letlhs()
	node.left = lhs.left
	node.list = lhs.list
	node.rest = lhs.rest
	self.reader.skip_white()
	var epos = self.reader.getpos()
	if self.reader.read_alpha() != "in" {
		panic(Err("Missing \"in\" after :for", epos))
	}
	node.right = self.parse_expr()
	self.add_node(node)
	self.push_context(node)
}

func (self *VimLParser) parse_cmd_endfor() {
	if self.context[0].type_ != NODE_FOR {
		panic(Err("E588: :endfor without :for", self.ea.cmdpos))
	}
	var node = Node(NODE_ENDFOR)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	self.context[0].endfor = node
	self.pop_context()
}

func (self *VimLParser) parse_cmd_continue() {
	if self.find_context(NODE_WHILE) == -1 && self.find_context(NODE_FOR) == -1 {
		panic(Err("E586: :continue without :while or :for", self.ea.cmdpos))
	}
	var node = Node(NODE_CONTINUE)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	self.add_node(node)
}

func (self *VimLParser) parse_cmd_break() {
	if self.find_context(NODE_WHILE) == -1 && self.find_context(NODE_FOR) == -1 {
		panic(Err("E587: :break without :while or :for", self.ea.cmdpos))
	}
	var node = Node(NODE_BREAK)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	self.add_node(node)
}

func (self *VimLParser) parse_cmd_try() {
	var node = Node(NODE_TRY)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	self.add_node(node)
	self.push_context(node)
}

func (self *VimLParser) parse_cmd_catch() {
	if self.context[0].type_ == NODE_FINALLY {
		panic(Err("E604: :catch after :finally", self.ea.cmdpos))
	} else if self.context[0].type_ != NODE_TRY && self.context[0].type_ != NODE_CATCH {
		panic(Err("E603: :catch without :try", self.ea.cmdpos))
	}
	if self.context[0].type_ != NODE_TRY {
		self.pop_context()
	}
	var node = Node(NODE_CATCH)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	self.reader.skip_white()
	if !self.ends_excmds(self.reader.peek()) {
		node.pattern, _ = self.parse_pattern(self.reader.get())
	}
	self.context[0].catch = append(self.context[0].catch, node)
	self.push_context(node)
}

func (self *VimLParser) parse_cmd_finally() {
	if self.context[0].type_ != NODE_TRY && self.context[0].type_ != NODE_CATCH {
		panic(Err("E606: :finally without :try", self.ea.cmdpos))
	}
	if self.context[0].type_ != NODE_TRY {
		self.pop_context()
	}
	var node = Node(NODE_FINALLY)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	self.context[0].finally = node
	self.push_context(node)
}

func (self *VimLParser) parse_cmd_endtry() {
	if self.context[0].type_ != NODE_TRY && self.context[0].type_ != NODE_CATCH && self.context[0].type_ != NODE_FINALLY {
		panic(Err("E602: :endtry without :try", self.ea.cmdpos))
	}
	if self.context[0].type_ != NODE_TRY {
		self.pop_context()
	}
	var node = Node(NODE_ENDTRY)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	self.context[0].endtry = node
	self.pop_context()
}

func (self *VimLParser) parse_cmd_throw() {
	var node = Node(NODE_THROW)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.left = self.parse_expr()
	self.add_node(node)
}

func (self *VimLParser) parse_cmd_echo() {
	var node = Node(NODE_ECHO)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.list = self.parse_exprlist()
	self.add_node(node)
}

func (self *VimLParser) parse_cmd_echon() {
	var node = Node(NODE_ECHON)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.list = self.parse_exprlist()
	self.add_node(node)
}

func (self *VimLParser) parse_cmd_echohl() {
	var node = Node(NODE_ECHOHL)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.str = ""
	for !self.ends_excmds(self.reader.peek()) {
		node.str += self.reader.get()
	}
	self.add_node(node)
}

func (self *VimLParser) parse_cmd_echomsg() {
	var node = Node(NODE_ECHOMSG)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.list = self.parse_exprlist()
	self.add_node(node)
}

func (self *VimLParser) parse_cmd_echoerr() {
	var node = Node(NODE_ECHOERR)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.list = self.parse_exprlist()
	self.add_node(node)
}

func (self *VimLParser) parse_cmd_execute() {
	var node = Node(NODE_EXECUTE)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.list = self.parse_exprlist()
	self.add_node(node)
}

func (self *VimLParser) parse_expr() *VimNode {
	return NewExprParser(self.reader).parse()
}

func (self *VimLParser) parse_exprlist() []*VimNode {
	var list []*VimNode
	for true {
		self.reader.skip_white()
		var c = self.reader.peek()
		if c != "\"" && self.ends_excmds(c) {
			break
		}
		var node = self.parse_expr()
		list = append(list, node)
	}
	return list
}

func (self *VimLParser) parse_lvalue_func() *VimNode {
	var p = NewLvalueParser(self.reader)
	var node = p.parse()
	if node.type_ == NODE_IDENTIFIER || node.type_ == NODE_CURLYNAME || node.type_ == NODE_SUBSCRIPT || node.type_ == NODE_DOT || node.type_ == NODE_OPTION || node.type_ == NODE_ENV || node.type_ == NODE_REG {
		return node
	}
	panic(Err("Invalid Expression", node.pos))
}

// FIXME:
func (self *VimLParser) parse_lvalue() *VimNode {
	var p = NewLvalueParser(self.reader)
	var node = p.parse()
	if node.type_ == NODE_IDENTIFIER {
		if !isvarname(node.value.(string)) {
			panic(Err(viml_printf("E461: Illegal variable name: %s", node.value), node.pos))
		}
	}
	if node.type_ == NODE_IDENTIFIER || node.type_ == NODE_CURLYNAME || node.type_ == NODE_SUBSCRIPT || node.type_ == NODE_SLICE || node.type_ == NODE_DOT || node.type_ == NODE_OPTION || node.type_ == NODE_ENV || node.type_ == NODE_REG {
		return node
	}
	panic(Err("Invalid Expression", node.pos))
}

func (self *VimLParser) parse_lvaluelist() []*VimNode {
	var list []*VimNode
	var node = self.parse_expr()
	list = append(list, node)
	for true {
		self.reader.skip_white()
		if self.ends_excmds(self.reader.peek()) {
			break
		}
		node = self.parse_lvalue()
		list = append(list, node)
	}
	return list
}

// FIXME:
func (self *VimLParser) parse_letlhs() *lhs {
	var lhs = &lhs{}
	var tokenizer = NewExprTokenizer(self.reader)
	if tokenizer.peek().type_ == TOKEN_SQOPEN {
		tokenizer.get()
		for true {
			var node = self.parse_lvalue()
			lhs.list = append(lhs.list, node)
			var token = tokenizer.get()
			if token.type_ == TOKEN_SQCLOSE {
				break
			} else if token.type_ == TOKEN_COMMA {
				continue
			} else if token.type_ == TOKEN_SEMICOLON {
				node = self.parse_lvalue()
				lhs.rest = node
				token = tokenizer.get()
				if token.type_ == TOKEN_SQCLOSE {
					break
				} else {
					panic(Err(viml_printf("E475 Invalid argument: %s", token.value), token.pos))
				}
			} else {
				panic(Err(viml_printf("E475 Invalid argument: %s", token.value), token.pos))
			}
		}
	} else {
		lhs.left = self.parse_lvalue()
	}
	return lhs
}

func (self *VimLParser) ends_excmds(c string) bool {
	return c == "" || c == "|" || c == "\"" || c == "<EOF>" || c == "<EOL>"
}

// FIXME: validate argument
func (self *VimLParser) parse_wincmd() {
	var c = self.reader.getn(1)
	if c == "" {
		panic(Err("E471: Argument required", self.reader.getpos()))
	} else if c == "g" || c == "\x07" {
		// <C-G>
		var c2 = self.reader.getn(1)
		if c2 == "" || iswhite(c2) {
			panic(Err("E474: Invalid Argument", self.reader.getpos()))
		}
	}
	var end = self.reader.getpos()
	self.reader.skip_white()
	if !self.ends_excmds(self.reader.peek()) {
		panic(Err("E474: Invalid Argument", self.reader.getpos()))
	}
	var node = Node(NODE_EXCMD)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.str = self.reader.getstr(self.ea.linepos, end)
	self.add_node(node)
}

// FIXME: validate argument
func (self *VimLParser) parse_cmd_syntax() {
	var end = self.reader.getpos()
	for true {
		end = self.reader.getpos()
		var c = self.reader.peek()
		if c == "/" || c == "'" || c == "\"" {
			self.reader.getn(1)
			self.parse_pattern(c)
		} else if c == "=" {
			self.reader.getn(1)
			self.parse_pattern(" ")
		} else if self.ends_excmds(c) {
			break
		}
		self.reader.getn(1)
	}
	var node = Node(NODE_EXCMD)
	node.pos = self.ea.cmdpos
	node.ea = self.ea
	node.str = self.reader.getstr(self.ea.linepos, end)
	self.add_node(node)
}

// To find new builtin_commands, run the below script.
// $ scripts/update_builtin_commands.sh /path/to/vim/src/ex_cmds.h
func (self *ExprTokenizer) __init__(reader *StringReader) {
	self.reader = reader
}

func (self *ExprTokenizer) peek() *ExprToken {
	var pos = self.reader.tell()
	var r = self.get()
	self.reader.seek_set(pos)
	return r
}

func (self *ExprTokenizer) get() *ExprToken {
	// FIXME: remove dirty hack
	if viml_has_key(self.cache, self.reader.tell()) {
		var x = self.cache[self.reader.tell()]
		self.reader.seek_set(x[0].(int))
		return x[1].(*ExprToken)
	}
	var pos = self.reader.tell()
	self.reader.skip_white()
	var r = self.get2()
	self.cache[pos] = []interface{}{self.reader.tell(), r}
	return r
}

func (self *ExprTokenizer) get2() *ExprToken {
	var r = self.reader
	var pos = r.getpos()
	var c = r.peek()
	if c == "<EOF>" {
		return self.token(TOKEN_EOF, c, pos)
	} else if c == "<EOL>" {
		r.seek_cur(1)
		return self.token(TOKEN_EOL, c, pos)
	} else if iswhite(c) {
		var s = r.read_white()
		return self.token(TOKEN_SPACE, s, pos)
	} else if c == "0" && (r.p(1) == "X" || r.p(1) == "x") && isxdigit(r.p(2)) {
		var s = r.getn(3)
		s += r.read_xdigit()
		return self.token(TOKEN_NUMBER, s, pos)
	} else if isdigit(c) {
		var s = r.read_digit()
		if r.p(0) == "." && isdigit(r.p(1)) {
			s += r.getn(1)
			s += r.read_digit()
			if (r.p(0) == "E" || r.p(0) == "e") && (isdigit(r.p(1)) || ((r.p(1) == "-" || r.p(1) == "+") && isdigit(r.p(2)))) {
				s += r.getn(2)
				s += r.read_digit()
			}
		}
		return self.token(TOKEN_NUMBER, s, pos)
	} else if c == "i" && r.p(1) == "s" && !isidc(r.p(2)) {
		if r.p(2) == "?" {
			r.seek_cur(3)
			return self.token(TOKEN_ISCI, "is?", pos)
		} else if r.p(2) == "#" {
			r.seek_cur(3)
			return self.token(TOKEN_ISCS, "is#", pos)
		} else {
			r.seek_cur(2)
			return self.token(TOKEN_IS, "is", pos)
		}
	} else if c == "i" && r.p(1) == "s" && r.p(2) == "n" && r.p(3) == "o" && r.p(4) == "t" && !isidc(r.p(5)) {
		if r.p(5) == "?" {
			r.seek_cur(6)
			return self.token(TOKEN_ISNOTCI, "isnot?", pos)
		} else if r.p(5) == "#" {
			r.seek_cur(6)
			return self.token(TOKEN_ISNOTCS, "isnot#", pos)
		} else {
			r.seek_cur(5)
			return self.token(TOKEN_ISNOT, "isnot", pos)
		}
	} else if isnamec1(c) {
		var s = r.read_name()
		return self.token(TOKEN_IDENTIFIER, s, pos)
	} else if c == "|" && r.p(1) == "|" {
		r.seek_cur(2)
		return self.token(TOKEN_OROR, "||", pos)
	} else if c == "&" && r.p(1) == "&" {
		r.seek_cur(2)
		return self.token(TOKEN_ANDAND, "&&", pos)
	} else if c == "=" && r.p(1) == "=" {
		if r.p(2) == "?" {
			r.seek_cur(3)
			return self.token(TOKEN_EQEQCI, "==?", pos)
		} else if r.p(2) == "#" {
			r.seek_cur(3)
			return self.token(TOKEN_EQEQCS, "==#", pos)
		} else {
			r.seek_cur(2)
			return self.token(TOKEN_EQEQ, "==", pos)
		}
	} else if c == "!" && r.p(1) == "=" {
		if r.p(2) == "?" {
			r.seek_cur(3)
			return self.token(TOKEN_NEQCI, "!=?", pos)
		} else if r.p(2) == "#" {
			r.seek_cur(3)
			return self.token(TOKEN_NEQCS, "!=#", pos)
		} else {
			r.seek_cur(2)
			return self.token(TOKEN_NEQ, "!=", pos)
		}
	} else if c == ">" && r.p(1) == "=" {
		if r.p(2) == "?" {
			r.seek_cur(3)
			return self.token(TOKEN_GTEQCI, ">=?", pos)
		} else if r.p(2) == "#" {
			r.seek_cur(3)
			return self.token(TOKEN_GTEQCS, ">=#", pos)
		} else {
			r.seek_cur(2)
			return self.token(TOKEN_GTEQ, ">=", pos)
		}
	} else if c == "<" && r.p(1) == "=" {
		if r.p(2) == "?" {
			r.seek_cur(3)
			return self.token(TOKEN_LTEQCI, "<=?", pos)
		} else if r.p(2) == "#" {
			r.seek_cur(3)
			return self.token(TOKEN_LTEQCS, "<=#", pos)
		} else {
			r.seek_cur(2)
			return self.token(TOKEN_LTEQ, "<=", pos)
		}
	} else if c == "=" && r.p(1) == "~" {
		if r.p(2) == "?" {
			r.seek_cur(3)
			return self.token(TOKEN_MATCHCI, "=~?", pos)
		} else if r.p(2) == "#" {
			r.seek_cur(3)
			return self.token(TOKEN_MATCHCS, "=~#", pos)
		} else {
			r.seek_cur(2)
			return self.token(TOKEN_MATCH, "=~", pos)
		}
	} else if c == "!" && r.p(1) == "~" {
		if r.p(2) == "?" {
			r.seek_cur(3)
			return self.token(TOKEN_NOMATCHCI, "!~?", pos)
		} else if r.p(2) == "#" {
			r.seek_cur(3)
			return self.token(TOKEN_NOMATCHCS, "!~#", pos)
		} else {
			r.seek_cur(2)
			return self.token(TOKEN_NOMATCH, "!~", pos)
		}
	} else if c == ">" {
		if r.p(1) == "?" {
			r.seek_cur(2)
			return self.token(TOKEN_GTCI, ">?", pos)
		} else if r.p(1) == "#" {
			r.seek_cur(2)
			return self.token(TOKEN_GTCS, ">#", pos)
		} else {
			r.seek_cur(1)
			return self.token(TOKEN_GT, ">", pos)
		}
	} else if c == "<" {
		if r.p(1) == "?" {
			r.seek_cur(2)
			return self.token(TOKEN_LTCI, "<?", pos)
		} else if r.p(1) == "#" {
			r.seek_cur(2)
			return self.token(TOKEN_LTCS, "<#", pos)
		} else {
			r.seek_cur(1)
			return self.token(TOKEN_LT, "<", pos)
		}
	} else if c == "+" {
		r.seek_cur(1)
		return self.token(TOKEN_PLUS, "+", pos)
	} else if c == "-" {
		if r.p(1) == ">" {
			r.seek_cur(2)
			return self.token(TOKEN_ARROW, "->", pos)
		} else {
			r.seek_cur(1)
			return self.token(TOKEN_MINUS, "-", pos)
		}
	} else if c == "." {
		if r.p(1) == "." && r.p(2) == "." {
			r.seek_cur(3)
			return self.token(TOKEN_DOTDOTDOT, "...", pos)
		} else {
			r.seek_cur(1)
			return self.token(TOKEN_DOT, ".", pos)
		}
	} else if c == "*" {
		r.seek_cur(1)
		return self.token(TOKEN_STAR, "*", pos)
	} else if c == "/" {
		r.seek_cur(1)
		return self.token(TOKEN_SLASH, "/", pos)
	} else if c == "%" {
		r.seek_cur(1)
		return self.token(TOKEN_PERCENT, "%", pos)
	} else if c == "!" {
		r.seek_cur(1)
		return self.token(TOKEN_NOT, "!", pos)
	} else if c == "?" {
		r.seek_cur(1)
		return self.token(TOKEN_QUESTION, "?", pos)
	} else if c == ":" {
		r.seek_cur(1)
		return self.token(TOKEN_COLON, ":", pos)
	} else if c == "#" {
		r.seek_cur(1)
		return self.token(TOKEN_SHARP, "#", pos)
	} else if c == "(" {
		r.seek_cur(1)
		return self.token(TOKEN_POPEN, "(", pos)
	} else if c == ")" {
		r.seek_cur(1)
		return self.token(TOKEN_PCLOSE, ")", pos)
	} else if c == "[" {
		r.seek_cur(1)
		return self.token(TOKEN_SQOPEN, "[", pos)
	} else if c == "]" {
		r.seek_cur(1)
		return self.token(TOKEN_SQCLOSE, "]", pos)
	} else if c == "{" {
		r.seek_cur(1)
		return self.token(TOKEN_COPEN, "{", pos)
	} else if c == "}" {
		r.seek_cur(1)
		return self.token(TOKEN_CCLOSE, "}", pos)
	} else if c == "," {
		r.seek_cur(1)
		return self.token(TOKEN_COMMA, ",", pos)
	} else if c == "'" {
		r.seek_cur(1)
		return self.token(TOKEN_SQUOTE, "'", pos)
	} else if c == "\"" {
		r.seek_cur(1)
		return self.token(TOKEN_DQUOTE, "\"", pos)
	} else if c == "$" {
		var s = r.getn(1)
		s += r.read_word()
		return self.token(TOKEN_ENV, s, pos)
	} else if c == "@" {
		// @<EOL> is treated as @"
		return self.token(TOKEN_REG, r.getn(2), pos)
	} else if c == "&" {
		var s = ""
		if (r.p(1) == "g" || r.p(1) == "l") && r.p(2) == ":" {
			s = r.getn(3) + r.read_word()
		} else {
			s = r.getn(1) + r.read_word()
		}
		return self.token(TOKEN_OPTION, s, pos)
	} else if c == "=" {
		r.seek_cur(1)
		return self.token(TOKEN_EQ, "=", pos)
	} else if c == "|" {
		r.seek_cur(1)
		return self.token(TOKEN_OR, "|", pos)
	} else if c == ";" {
		r.seek_cur(1)
		return self.token(TOKEN_SEMICOLON, ";", pos)
	} else if c == "`" {
		r.seek_cur(1)
		return self.token(TOKEN_BACKTICK, "`", pos)
	} else {
		panic(Err(viml_printf("unexpected character: %s", c), self.reader.getpos()))
	}
}

func (self *ExprTokenizer) get_sstring() string {
	self.reader.skip_white()
	var c = self.reader.p(0)
	if c != "'" {
		panic(Err(viml_printf("unexpected character: %s", c), self.reader.getpos()))
	}
	self.reader.seek_cur(1)
	var s = ""
	for true {
		c = self.reader.p(0)
		if c == "<EOF>" || c == "<EOL>" {
			panic(Err("unexpected EOL", self.reader.getpos()))
		} else if c == "'" {
			self.reader.seek_cur(1)
			if self.reader.p(0) == "'" {
				self.reader.seek_cur(1)
				s += "''"
			} else {
				break
			}
		} else {
			self.reader.seek_cur(1)
			s += c
		}
	}
	return s
}

func (self *ExprTokenizer) get_dstring() string {
	self.reader.skip_white()
	var c = self.reader.p(0)
	if c != "\"" {
		panic(Err(viml_printf("unexpected character: %s", c), self.reader.getpos()))
	}
	self.reader.seek_cur(1)
	var s = ""
	for true {
		c = self.reader.p(0)
		if c == "<EOF>" || c == "<EOL>" {
			panic(Err("unexpectd EOL", self.reader.getpos()))
		} else if c == "\"" {
			self.reader.seek_cur(1)
			break
		} else if c == "\\" {
			self.reader.seek_cur(1)
			s += c
			c = self.reader.p(0)
			if c == "<EOF>" || c == "<EOL>" {
				panic(Err("ExprTokenizer: unexpected EOL", self.reader.getpos()))
			}
			self.reader.seek_cur(1)
			s += c
		} else {
			self.reader.seek_cur(1)
			s += c
		}
	}
	return s
}

func (self *ExprParser) __init__(reader *StringReader) {
	self.reader = reader
	self.tokenizer = NewExprTokenizer(reader)
}

func (self *ExprParser) parse() *VimNode {
	return self.parse_expr1()
}

// expr1: expr2 ? expr1 : expr1
func (self *ExprParser) parse_expr1() *VimNode {
	var left = self.parse_expr2()
	var pos = self.reader.tell()
	var token = self.tokenizer.get()
	if token.type_ == TOKEN_QUESTION {
		var node = Node(NODE_TERNARY)
		node.pos = token.pos
		node.cond = left
		node.left = self.parse_expr1()
		token = self.tokenizer.get()
		if token.type_ != TOKEN_COLON {
			panic(Err(viml_printf("unexpected token: %s", token.value), token.pos))
		}
		node.right = self.parse_expr1()
		left = node
	} else {
		self.reader.seek_set(pos)
	}
	return left
}

// expr2: expr3 || expr3 ..
func (self *ExprParser) parse_expr2() *VimNode {
	var left = self.parse_expr3()
	for true {
		var pos = self.reader.tell()
		var token = self.tokenizer.get()
		if token.type_ == TOKEN_OROR {
			var node = Node(NODE_OR)
			node.pos = token.pos
			node.left = left
			node.right = self.parse_expr3()
			left = node
		} else {
			self.reader.seek_set(pos)
			break
		}
	}
	return left
}

// expr3: expr4 && expr4
func (self *ExprParser) parse_expr3() *VimNode {
	var left = self.parse_expr4()
	for true {
		var pos = self.reader.tell()
		var token = self.tokenizer.get()
		if token.type_ == TOKEN_ANDAND {
			var node = Node(NODE_AND)
			node.pos = token.pos
			node.left = left
			node.right = self.parse_expr4()
			left = node
		} else {
			self.reader.seek_set(pos)
			break
		}
	}
	return left
}

// expr4: expr5 == expr5
//        expr5 != expr5
//        expr5 >  expr5
//        expr5 >= expr5
//        expr5 <  expr5
//        expr5 <= expr5
//        expr5 =~ expr5
//        expr5 !~ expr5
//
//        expr5 ==? expr5
//        expr5 ==# expr5
//        etc.
//
//        expr5 is expr5
//        expr5 isnot expr5
func (self *ExprParser) parse_expr4() *VimNode {
	var left = self.parse_expr5()
	var pos = self.reader.tell()
	var token = self.tokenizer.get()
	if token.type_ == TOKEN_EQEQ {
		var node = Node(NODE_EQUAL)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_EQEQCI {
		var node = Node(NODE_EQUALCI)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_EQEQCS {
		var node = Node(NODE_EQUALCS)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_NEQ {
		var node = Node(NODE_NEQUAL)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_NEQCI {
		var node = Node(NODE_NEQUALCI)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_NEQCS {
		var node = Node(NODE_NEQUALCS)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_GT {
		var node = Node(NODE_GREATER)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_GTCI {
		var node = Node(NODE_GREATERCI)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_GTCS {
		var node = Node(NODE_GREATERCS)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_GTEQ {
		var node = Node(NODE_GEQUAL)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_GTEQCI {
		var node = Node(NODE_GEQUALCI)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_GTEQCS {
		var node = Node(NODE_GEQUALCS)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_LT {
		var node = Node(NODE_SMALLER)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_LTCI {
		var node = Node(NODE_SMALLERCI)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_LTCS {
		var node = Node(NODE_SMALLERCS)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_LTEQ {
		var node = Node(NODE_SEQUAL)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_LTEQCI {
		var node = Node(NODE_SEQUALCI)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_LTEQCS {
		var node = Node(NODE_SEQUALCS)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_MATCH {
		var node = Node(NODE_MATCH)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_MATCHCI {
		var node = Node(NODE_MATCHCI)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_MATCHCS {
		var node = Node(NODE_MATCHCS)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_NOMATCH {
		var node = Node(NODE_NOMATCH)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_NOMATCHCI {
		var node = Node(NODE_NOMATCHCI)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_NOMATCHCS {
		var node = Node(NODE_NOMATCHCS)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_IS {
		var node = Node(NODE_IS)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_ISCI {
		var node = Node(NODE_ISCI)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_ISCS {
		var node = Node(NODE_ISCS)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_ISNOT {
		var node = Node(NODE_ISNOT)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_ISNOTCI {
		var node = Node(NODE_ISNOTCI)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else if token.type_ == TOKEN_ISNOTCS {
		var node = Node(NODE_ISNOTCS)
		node.pos = token.pos
		node.left = left
		node.right = self.parse_expr5()
		left = node
	} else {
		self.reader.seek_set(pos)
	}
	return left
}

// expr5: expr6 + expr6 ..
//        expr6 - expr6 ..
//        expr6 . expr6 ..
func (self *ExprParser) parse_expr5() *VimNode {
	var left = self.parse_expr6()
	for true {
		var pos = self.reader.tell()
		var token = self.tokenizer.get()
		if token.type_ == TOKEN_PLUS {
			var node = Node(NODE_ADD)
			node.pos = token.pos
			node.left = left
			node.right = self.parse_expr6()
			left = node
		} else if token.type_ == TOKEN_MINUS {
			var node = Node(NODE_SUBTRACT)
			node.pos = token.pos
			node.left = left
			node.right = self.parse_expr6()
			left = node
		} else if token.type_ == TOKEN_DOT {
			var node = Node(NODE_CONCAT)
			node.pos = token.pos
			node.left = left
			node.right = self.parse_expr6()
			left = node
		} else {
			self.reader.seek_set(pos)
			break
		}
	}
	return left
}

// expr6: expr7 * expr7 ..
//        expr7 / expr7 ..
//        expr7 % expr7 ..
func (self *ExprParser) parse_expr6() *VimNode {
	var left = self.parse_expr7()
	for true {
		var pos = self.reader.tell()
		var token = self.tokenizer.get()
		if token.type_ == TOKEN_STAR {
			var node = Node(NODE_MULTIPLY)
			node.pos = token.pos
			node.left = left
			node.right = self.parse_expr7()
			left = node
		} else if token.type_ == TOKEN_SLASH {
			var node = Node(NODE_DIVIDE)
			node.pos = token.pos
			node.left = left
			node.right = self.parse_expr7()
			left = node
		} else if token.type_ == TOKEN_PERCENT {
			var node = Node(NODE_REMAINDER)
			node.pos = token.pos
			node.left = left
			node.right = self.parse_expr7()
			left = node
		} else {
			self.reader.seek_set(pos)
			break
		}
	}
	return left
}

// expr7: ! expr7
//        - expr7
//        + expr7
func (self *ExprParser) parse_expr7() *VimNode {
	var pos = self.reader.tell()
	var token = self.tokenizer.get()
	if token.type_ == TOKEN_NOT {
		var node = Node(NODE_NOT)
		node.pos = token.pos
		node.left = self.parse_expr7()
		return node
	} else if token.type_ == TOKEN_MINUS {
		var node = Node(NODE_MINUS)
		node.pos = token.pos
		node.left = self.parse_expr7()
		return node
	} else if token.type_ == TOKEN_PLUS {
		var node = Node(NODE_PLUS)
		node.pos = token.pos
		node.left = self.parse_expr7()
		return node
	} else {
		self.reader.seek_set(pos)
		var node = self.parse_expr8()
		return node
	}
}

// expr8: expr8[expr1]
//        expr8[expr1 : expr1]
//        expr8.name
//        expr8(expr1, ...)
func (self *ExprParser) parse_expr8() *VimNode {
	var left = self.parse_expr9()
	for true {
		var pos = self.reader.tell()
		var c = self.reader.peek()
		var token = self.tokenizer.get()
		if !iswhite(c) && token.type_ == TOKEN_SQOPEN {
			var npos = token.pos
			if self.tokenizer.peek().type_ == TOKEN_COLON {
				self.tokenizer.get()
				var node = Node(NODE_SLICE)
				node.pos = npos
				node.left = left
				node.rlist = []*VimNode{nil, nil}
				token = self.tokenizer.peek()
				if token.type_ != TOKEN_SQCLOSE {
					node.rlist[1] = self.parse_expr1()
				}
				token = self.tokenizer.get()
				if token.type_ != TOKEN_SQCLOSE {
					panic(Err(viml_printf("unexpected token: %s", token.value), token.pos))
				}
				left = node
			} else {
				var right = self.parse_expr1()
				if self.tokenizer.peek().type_ == TOKEN_COLON {
					self.tokenizer.get()
					var node = Node(NODE_SLICE)
					node.pos = npos
					node.left = left
					node.rlist = []*VimNode{right, nil}
					token = self.tokenizer.peek()
					if token.type_ != TOKEN_SQCLOSE {
						node.rlist[1] = self.parse_expr1()
					}
					token = self.tokenizer.get()
					if token.type_ != TOKEN_SQCLOSE {
						panic(Err(viml_printf("unexpected token: %s", token.value), token.pos))
					}
					left = node
				} else {
					var node = Node(NODE_SUBSCRIPT)
					node.pos = npos
					node.left = left
					node.right = right
					token = self.tokenizer.get()
					if token.type_ != TOKEN_SQCLOSE {
						panic(Err(viml_printf("unexpected token: %s", token.value), token.pos))
					}
					left = node
				}
			}
		} else if token.type_ == TOKEN_POPEN {
			var node = Node(NODE_CALL)
			node.pos = token.pos
			node.left = left
			if self.tokenizer.peek().type_ == TOKEN_PCLOSE {
				self.tokenizer.get()
			} else {
				for true {
					node.rlist = append(node.rlist, self.parse_expr1())
					token = self.tokenizer.get()
					if token.type_ == TOKEN_COMMA {
						// XXX: Vim allows foo(a, b, ).  Lint should warn it.
						if self.tokenizer.peek().type_ == TOKEN_PCLOSE {
							self.tokenizer.get()
							break
						}
					} else if token.type_ == TOKEN_PCLOSE {
						break
					} else {
						panic(Err(viml_printf("unexpected token: %s", token.value), token.pos))
					}
				}
			}
			if len(node.rlist) > MAX_FUNC_ARGS {
				// TODO: funcname E740: Too many arguments for function: %s
				panic(Err("E740: Too many arguments for function", node.pos))
			}
			left = node
		} else if !iswhite(c) && token.type_ == TOKEN_DOT {
			var node = self.parse_dot(token, left)
			if node == nil {
				self.reader.seek_set(pos)
				break
			}
			left = node
		} else {
			self.reader.seek_set(pos)
			break
		}
	}
	return left
}

// expr9: number
//        "string"
//        'string'
//        [expr1, ...]
//        {expr1: expr1, ...}
//        {args -> expr1}
//        &option
//        (expr1)
//        variable
//        var{ria}ble
//        $VAR
//        @r
//        function(expr1, ...)
//        func{ti}on(expr1, ...)
func (self *ExprParser) parse_expr9() *VimNode {
	var pos = self.reader.tell()
	var token = self.tokenizer.get()
	var node = Node(-1)
	if token.type_ == TOKEN_NUMBER {
		node = Node(NODE_NUMBER)
		node.pos = token.pos
		node.value = token.value
	} else if token.type_ == TOKEN_DQUOTE {
		self.reader.seek_set(pos)
		node = Node(NODE_STRING)
		node.pos = token.pos
		node.value = "\"" + self.tokenizer.get_dstring() + "\""
	} else if token.type_ == TOKEN_SQUOTE {
		self.reader.seek_set(pos)
		node = Node(NODE_STRING)
		node.pos = token.pos
		node.value = "'" + self.tokenizer.get_sstring() + "'"
	} else if token.type_ == TOKEN_SQOPEN {
		node = Node(NODE_LIST)
		node.pos = token.pos
		node.value = []interface{}{}
		token = self.tokenizer.peek()
		if token.type_ == TOKEN_SQCLOSE {
			self.tokenizer.get()
		} else {
			for true {
				node.value = append(node.value.([]interface{}), self.parse_expr1())
				token = self.tokenizer.peek()
				if token.type_ == TOKEN_COMMA {
					self.tokenizer.get()
					if self.tokenizer.peek().type_ == TOKEN_SQCLOSE {
						self.tokenizer.get()
						break
					}
				} else if token.type_ == TOKEN_SQCLOSE {
					self.tokenizer.get()
					break
				} else {
					panic(Err(viml_printf("unexpected token: %s", token.value), token.pos))
				}
			}
		}
	} else if token.type_ == TOKEN_COPEN {
		var savepos = self.reader.tell()
		var nodepos = token.pos
		token = self.tokenizer.get()
		var lambda = token.type_ == TOKEN_ARROW
		if !lambda && !(token.type_ == TOKEN_SQUOTE || token.type_ == TOKEN_DQUOTE) {
			// if the token type is stirng, we cannot peek next token and we can
			// assume it's not lambda.
			var token2 = self.tokenizer.peek()
			lambda = token2.type_ == TOKEN_ARROW || token2.type_ == TOKEN_COMMA
		}
		// fallback to dict or {expr} if true
		var fallback = false
		if lambda {
			// lambda {token,...} {->...} {token->...}
			node = Node(NODE_LAMBDA)
			node.pos = nodepos
			var named = map[string]interface{}{}
			for true {
				if token.type_ == TOKEN_ARROW {
					break
				} else if token.type_ == TOKEN_IDENTIFIER {
					if !isargname(token.value) {
						panic(Err(viml_printf("E125: Illegal argument: %s", token.value), token.pos))
					} else if viml_has_key(named, token.value) {
						panic(Err(viml_printf("E853: Duplicate argument name: %s", token.value), token.pos))
					}
					named[token.value] = 1
					var varnode = Node(NODE_IDENTIFIER)
					varnode.pos = token.pos
					varnode.value = token.value
					// XXX: Vim doesn't skip white space before comma.  {a ,b -> ...} => E475
					if iswhite(self.reader.p(0)) && self.tokenizer.peek().type_ == TOKEN_COMMA {
						panic(Err("E475: Invalid argument: White space is not allowed before comma", self.reader.getpos()))
					}
					token = self.tokenizer.get()
					node.rlist = append(node.rlist, varnode)
					if token.type_ == TOKEN_COMMA {
						// XXX: Vim allows last comma.  {a, b, -> ...} => OK
						token = self.tokenizer.peek()
						if token.type_ == TOKEN_ARROW {
							self.tokenizer.get()
							break
						}
					} else if token.type_ == TOKEN_ARROW {
						break
					} else {
						panic(Err(viml_printf("unexpected token: %s, type: %d", token.value, token.type_), token.pos))
					}
				} else if token.type_ == TOKEN_DOTDOTDOT {
					var varnode = Node(NODE_IDENTIFIER)
					varnode.pos = token.pos
					varnode.value = token.value
					node.rlist = append(node.rlist, varnode)
					token = self.tokenizer.peek()
					if token.type_ == TOKEN_ARROW {
						self.tokenizer.get()
						break
					} else {
						panic(Err(viml_printf("unexpected token: %s", token.value), token.pos))
					}
				} else {
					fallback = true
					break
				}
				token = self.tokenizer.get()
			}
			if !fallback {
				node.left = self.parse_expr1()
				token = self.tokenizer.get()
				if token.type_ != TOKEN_CCLOSE {
					panic(Err(viml_printf("unexpected token: %s", token.value), token.pos))
				}
				return node
			}
		}
		// dict
		node = Node(NODE_DICT)
		node.pos = nodepos
		node.value = []interface{}{}
		self.reader.seek_set(savepos)
		token = self.tokenizer.peek()
		if token.type_ == TOKEN_CCLOSE {
			self.tokenizer.get()
			return node
		}
		for {
			var key = self.parse_expr1()
			token = self.tokenizer.get()
			if token.type_ == TOKEN_CCLOSE {
				if !viml_empty(node.value) {
					panic(Err(viml_printf("unexpected token: %s", token.value), token.pos))
				}
				self.reader.seek_set(pos)
				node = self.parse_identifier()
				break
			}
			if token.type_ != TOKEN_COLON {
				panic(Err(viml_printf("unexpected token: %s", token.value), token.pos))
			}
			var val = self.parse_expr1()
			node.value = append(node.value.([]interface{}), []interface{}{key, val})
			token = self.tokenizer.get()
			if token.type_ == TOKEN_COMMA {
				if self.tokenizer.peek().type_ == TOKEN_CCLOSE {
					self.tokenizer.get()
					break
				}
			} else if token.type_ == TOKEN_CCLOSE {
				break
			} else {
				panic(Err(viml_printf("unexpected token: %s", token.value), token.pos))
			}
		}
		return node
	} else if token.type_ == TOKEN_POPEN {
		node = Node(NODE_PARENEXPR)
		node.pos = token.pos
		node.value = self.parse_expr1()
		token = self.tokenizer.get()
		if token.type_ != TOKEN_PCLOSE {
			panic(Err(viml_printf("unexpected token: %s", token.value), token.pos))
		}
	} else if token.type_ == TOKEN_OPTION {
		node = Node(NODE_OPTION)
		node.pos = token.pos
		node.value = token.value
	} else if token.type_ == TOKEN_IDENTIFIER {
		self.reader.seek_set(pos)
		node = self.parse_identifier()
	} else if false && (token.type_ == TOKEN_COLON || token.type_ == TOKEN_SHARP) {
		// XXX: no parse error but invalid expression
		self.reader.seek_set(pos)
		node = self.parse_identifier()
	} else if token.type_ == TOKEN_LT && viml_equalci(self.reader.peekn(4), "SID>") {
		self.reader.seek_set(pos)
		node = self.parse_identifier()
	} else if token.type_ == TOKEN_IS || token.type_ == TOKEN_ISCS || token.type_ == TOKEN_ISNOT || token.type_ == TOKEN_ISNOTCS {
		self.reader.seek_set(pos)
		node = self.parse_identifier()
	} else if token.type_ == TOKEN_ENV {
		node = Node(NODE_ENV)
		node.pos = token.pos
		node.value = token.value
	} else if token.type_ == TOKEN_REG {
		node = Node(NODE_REG)
		node.pos = token.pos
		node.value = token.value
	} else {
		panic(Err(viml_printf("unexpected token: %s", token.value), token.pos))
	}
	return node
}

// SUBSCRIPT or CONCAT
//   dict "." [0-9A-Za-z_]+ => (subscript dict key)
//   str  "." expr6         => (concat str expr6)
func (self *ExprParser) parse_dot(token *ExprToken, left *VimNode) *VimNode {
	if left.type_ != NODE_IDENTIFIER && left.type_ != NODE_CURLYNAME && left.type_ != NODE_DICT && left.type_ != NODE_SUBSCRIPT && left.type_ != NODE_CALL && left.type_ != NODE_DOT {
		return nil
	}
	if !iswordc(self.reader.p(0)) {
		return nil
	}
	var pos = self.reader.getpos()
	var name = self.reader.read_word()
	if isnamec(self.reader.p(0)) {
		// XXX: foo is str => ok, foo is obj => invalid expression
		// foo.s:bar or foo.bar#baz
		return nil
	}
	var node = Node(NODE_DOT)
	node.pos = token.pos
	node.left = left
	node.right = Node(NODE_IDENTIFIER)
	node.right.pos = pos
	node.right.value = name
	return node
}

func (self *ExprParser) parse_identifier() *VimNode {
	self.reader.skip_white()
	var npos = self.reader.getpos()
	var curly_parts = self.parse_curly_parts()
	if len(curly_parts) == 1 && curly_parts[0].type_ == NODE_CURLYNAMEPART {
		var node = Node(NODE_IDENTIFIER)
		node.pos = npos
		node.value = curly_parts[0].value
		return node
	} else {
		var node = Node(NODE_CURLYNAME)
		node.pos = npos
		node.value = curly_parts
		return node
	}
}

func (self *ExprParser) parse_curly_parts() []*VimNode {
	var curly_parts []*VimNode
	var c = self.reader.peek()
	var pos = self.reader.getpos()
	if c == "<" && viml_equalci(self.reader.peekn(5), "<SID>") {
		var name = self.reader.getn(5)
		var node = Node(NODE_CURLYNAMEPART)
		node.curly = false
		// Keep backword compatibility for the curly attribute
		node.pos = pos
		node.value = name
		curly_parts = append(curly_parts, node)
	}
	for true {
		c = self.reader.peek()
		if isnamec(c) {
			pos = self.reader.getpos()
			var name = self.reader.read_name()
			var node = Node(NODE_CURLYNAMEPART)
			node.curly = false
			// Keep backword compatibility for the curly attribute
			node.pos = pos
			node.value = name
			curly_parts = append(curly_parts, node)
		} else if c == "{" {
			self.reader.get()
			pos = self.reader.getpos()
			var node = Node(NODE_CURLYNAMEEXPR)
			node.curly = true
			// Keep backword compatibility for the curly attribute
			node.pos = pos
			node.value = self.parse_expr1()
			curly_parts = append(curly_parts, node)
			self.reader.skip_white()
			c = self.reader.p(0)
			if c != "}" {
				panic(Err(viml_printf("unexpected token: %s", c), self.reader.getpos()))
			}
			self.reader.seek_cur(1)
		} else {
			break
		}
	}
	return curly_parts
}

func (self *LvalueParser) parse() *VimNode {
	return self.parse_lv8()
}

// expr8: expr8[expr1]
//        expr8[expr1 : expr1]
//        expr8.name
func (self *LvalueParser) parse_lv8() *VimNode {
	var left = self.parse_lv9()
	for true {
		var pos = self.reader.tell()
		var c = self.reader.peek()
		var token = self.tokenizer.get()
		if !iswhite(c) && token.type_ == TOKEN_SQOPEN {
			var npos = token.pos
			var node = Node(-1)
			if self.tokenizer.peek().type_ == TOKEN_COLON {
				self.tokenizer.get()
				node = Node(NODE_SLICE)
				node.pos = npos
				node.left = left
				node.rlist = []*VimNode{nil, nil}
				token = self.tokenizer.peek()
				if token.type_ != TOKEN_SQCLOSE {
					node.rlist[1] = self.parse_expr1()
				}
				token = self.tokenizer.get()
				if token.type_ != TOKEN_SQCLOSE {
					panic(Err(viml_printf("unexpected token: %s", token.value), token.pos))
				}
			} else {
				var right = self.parse_expr1()
				if self.tokenizer.peek().type_ == TOKEN_COLON {
					self.tokenizer.get()
					node = Node(NODE_SLICE)
					node.pos = npos
					node.left = left
					node.rlist = []*VimNode{right, nil}
					token = self.tokenizer.peek()
					if token.type_ != TOKEN_SQCLOSE {
						node.rlist[1] = self.parse_expr1()
					}
					token = self.tokenizer.get()
					if token.type_ != TOKEN_SQCLOSE {
						panic(Err(viml_printf("unexpected token: %s", token.value), token.pos))
					}
				} else {
					node = Node(NODE_SUBSCRIPT)
					node.pos = npos
					node.left = left
					node.right = right
					token = self.tokenizer.get()
					if token.type_ != TOKEN_SQCLOSE {
						panic(Err(viml_printf("unexpected token: %s", token.value), token.pos))
					}
				}
			}
			left = node
		} else if !iswhite(c) && token.type_ == TOKEN_DOT {
			var node = self.parse_dot(token, left)
			if node == nil {
				self.reader.seek_set(pos)
				break
			}
			left = node
		} else {
			self.reader.seek_set(pos)
			break
		}
	}
	return left
}

// expr9: &option
//        variable
//        var{ria}ble
//        $VAR
//        @r
func (self *LvalueParser) parse_lv9() *VimNode {
	var pos = self.reader.tell()
	var token = self.tokenizer.get()
	var node = Node(-1)
	if token.type_ == TOKEN_COPEN {
		self.reader.seek_set(pos)
		node = self.parse_identifier()
	} else if token.type_ == TOKEN_OPTION {
		node = Node(NODE_OPTION)
		node.pos = token.pos
		node.value = token.value
	} else if token.type_ == TOKEN_IDENTIFIER {
		self.reader.seek_set(pos)
		node = self.parse_identifier()
	} else if token.type_ == TOKEN_LT && viml_equalci(self.reader.peekn(4), "SID>") {
		self.reader.seek_set(pos)
		node = self.parse_identifier()
	} else if token.type_ == TOKEN_ENV {
		node = Node(NODE_ENV)
		node.pos = token.pos
		node.value = token.value
	} else if token.type_ == TOKEN_REG {
		node = Node(NODE_REG)
		node.pos = token.pos
		node.pos = token.pos
		node.value = token.value
	} else {
		panic(Err(viml_printf("unexpected token: %s", token.value), token.pos))
	}
	return node
}

func (self *StringReader) eof() bool {
	return self.i >= len(self.buf)
}

func (self *StringReader) tell() int {
	return self.i
}

func (self *StringReader) seek_set(i int) {
	self.i = i
}

func (self *StringReader) seek_cur(i int) {
	self.i = self.i + i
}

func (self *StringReader) seek_end(i int) {
	self.i = len(self.buf) + i
}

func (self *StringReader) p(i int) string {
	if self.i >= len(self.buf) {
		return "<EOF>"
	}
	return self.buf[self.i+i]
}

func (self *StringReader) peek() string {
	if self.i >= len(self.buf) {
		return "<EOF>"
	}
	return self.buf[self.i]
}

func (self *StringReader) get() string {
	if self.i >= len(self.buf) {
		return "<EOF>"
	}
	self.i += 1
	return self.buf[self.i-1]
}

func (self *StringReader) peekn(n int) string {
	var pos = self.tell()
	var r = self.getn(n)
	self.seek_set(pos)
	return r
}

func (self *StringReader) getn(n int) string {
	var r = ""
	var j = 0
	for self.i < len(self.buf) && (n < 0 || j < n) {
		var c = self.buf[self.i]
		if c == "<EOL>" {
			break
		}
		r += c
		self.i += 1
		j += 1
	}
	return r
}

func (self *StringReader) peekline() string {
	return self.peekn(-1)
}

func (self *StringReader) readline() string {
	var r = self.getn(-1)
	self.get()
	return r
}

func (self *StringReader) getstr(begin *pos, end *pos) string {
	var r = ""
	for _, i := range viml_range(begin.i, end.i-1) {
		if i >= len(self.buf) {
			break
		}
		var c = self.buf[i]
		if c == "<EOL>" {
			c = "\n"
		}
		r += c
	}
	return r
}

func (self *StringReader) setpos(pos *pos) {
	self.i = pos.i
}

func (self *StringReader) read_alpha() string {
	var r = ""
	for isalpha(self.peekn(1)) {
		r += self.getn(1)
	}
	return r
}

func (self *StringReader) read_alnum() string {
	var r = ""
	for isalnum(self.peekn(1)) {
		r += self.getn(1)
	}
	return r
}

func (self *StringReader) read_digit() string {
	var r = ""
	for isdigit(self.peekn(1)) {
		r += self.getn(1)
	}
	return r
}

func (self *StringReader) read_odigit() string {
	var r = ""
	for isodigit(self.peekn(1)) {
		r += self.getn(1)
	}
	return r
}

func (self *StringReader) read_xdigit() string {
	var r = ""
	for isxdigit(self.peekn(1)) {
		r += self.getn(1)
	}
	return r
}

func (self *StringReader) read_integer() string {
	var r = ""
	var c = self.peekn(1)
	if c == "-" || c == "+" {
		r = self.getn(1)
	}
	return r + self.read_digit()
}

func (self *StringReader) read_word() string {
	var r = ""
	for iswordc(self.peekn(1)) {
		r += self.getn(1)
	}
	return r
}

func (self *StringReader) read_white() string {
	var r = ""
	for iswhite(self.peekn(1)) {
		r += self.getn(1)
	}
	return r
}

func (self *StringReader) read_nonwhite() string {
	var r = ""
	for !iswhite(self.peekn(1)) {
		r += self.getn(1)
	}
	return r
}

func (self *StringReader) read_name() string {
	var r = ""
	for isnamec(self.peekn(1)) {
		r += self.getn(1)
	}
	return r
}

func (self *StringReader) skip_white() {
	for iswhite(self.peekn(1)) {
		self.seek_cur(1)
	}
}

func (self *StringReader) skip_white_and_colon() {
	for true {
		var c = self.peekn(1)
		if !iswhite(c) && c != ":" {
			break
		}
		self.seek_cur(1)
	}
}

func (self *Compiler) compile(node *VimNode) interface{} {
	if node.type_ == NODE_TOPLEVEL {
		return self.compile_toplevel(node)
	} else if node.type_ == NODE_COMMENT {
		self.compile_comment(node)
		return nil
	} else if node.type_ == NODE_EXCMD {
		self.compile_excmd(node)
		return nil
	} else if node.type_ == NODE_FUNCTION {
		self.compile_function(node)
		return nil
	} else if node.type_ == NODE_DELFUNCTION {
		self.compile_delfunction(node)
		return nil
	} else if node.type_ == NODE_RETURN {
		self.compile_return(node)
		return nil
	} else if node.type_ == NODE_EXCALL {
		self.compile_excall(node)
		return nil
	} else if node.type_ == NODE_LET {
		self.compile_let(node)
		return nil
	} else if node.type_ == NODE_UNLET {
		self.compile_unlet(node)
		return nil
	} else if node.type_ == NODE_LOCKVAR {
		self.compile_lockvar(node)
		return nil
	} else if node.type_ == NODE_UNLOCKVAR {
		self.compile_unlockvar(node)
		return nil
	} else if node.type_ == NODE_IF {
		self.compile_if(node)
		return nil
	} else if node.type_ == NODE_WHILE {
		self.compile_while(node)
		return nil
	} else if node.type_ == NODE_FOR {
		self.compile_for(node)
		return nil
	} else if node.type_ == NODE_CONTINUE {
		self.compile_continue(node)
		return nil
	} else if node.type_ == NODE_BREAK {
		self.compile_break(node)
		return nil
	} else if node.type_ == NODE_TRY {
		self.compile_try(node)
		return nil
	} else if node.type_ == NODE_THROW {
		self.compile_throw(node)
		return nil
	} else if node.type_ == NODE_ECHO {
		self.compile_echo(node)
		return nil
	} else if node.type_ == NODE_ECHON {
		self.compile_echon(node)
		return nil
	} else if node.type_ == NODE_ECHOHL {
		self.compile_echohl(node)
		return nil
	} else if node.type_ == NODE_ECHOMSG {
		self.compile_echomsg(node)
		return nil
	} else if node.type_ == NODE_ECHOERR {
		self.compile_echoerr(node)
		return nil
	} else if node.type_ == NODE_EXECUTE {
		self.compile_execute(node)
		return nil
	} else if node.type_ == NODE_TERNARY {
		return self.compile_ternary(node)
	} else if node.type_ == NODE_OR {
		return self.compile_or(node)
	} else if node.type_ == NODE_AND {
		return self.compile_and(node)
	} else if node.type_ == NODE_EQUAL {
		return self.compile_equal(node)
	} else if node.type_ == NODE_EQUALCI {
		return self.compile_equalci(node)
	} else if node.type_ == NODE_EQUALCS {
		return self.compile_equalcs(node)
	} else if node.type_ == NODE_NEQUAL {
		return self.compile_nequal(node)
	} else if node.type_ == NODE_NEQUALCI {
		return self.compile_nequalci(node)
	} else if node.type_ == NODE_NEQUALCS {
		return self.compile_nequalcs(node)
	} else if node.type_ == NODE_GREATER {
		return self.compile_greater(node)
	} else if node.type_ == NODE_GREATERCI {
		return self.compile_greaterci(node)
	} else if node.type_ == NODE_GREATERCS {
		return self.compile_greatercs(node)
	} else if node.type_ == NODE_GEQUAL {
		return self.compile_gequal(node)
	} else if node.type_ == NODE_GEQUALCI {
		return self.compile_gequalci(node)
	} else if node.type_ == NODE_GEQUALCS {
		return self.compile_gequalcs(node)
	} else if node.type_ == NODE_SMALLER {
		return self.compile_smaller(node)
	} else if node.type_ == NODE_SMALLERCI {
		return self.compile_smallerci(node)
	} else if node.type_ == NODE_SMALLERCS {
		return self.compile_smallercs(node)
	} else if node.type_ == NODE_SEQUAL {
		return self.compile_sequal(node)
	} else if node.type_ == NODE_SEQUALCI {
		return self.compile_sequalci(node)
	} else if node.type_ == NODE_SEQUALCS {
		return self.compile_sequalcs(node)
	} else if node.type_ == NODE_MATCH {
		return self.compile_match(node)
	} else if node.type_ == NODE_MATCHCI {
		return self.compile_matchci(node)
	} else if node.type_ == NODE_MATCHCS {
		return self.compile_matchcs(node)
	} else if node.type_ == NODE_NOMATCH {
		return self.compile_nomatch(node)
	} else if node.type_ == NODE_NOMATCHCI {
		return self.compile_nomatchci(node)
	} else if node.type_ == NODE_NOMATCHCS {
		return self.compile_nomatchcs(node)
	} else if node.type_ == NODE_IS {
		return self.compile_is(node)
	} else if node.type_ == NODE_ISCI {
		return self.compile_isci(node)
	} else if node.type_ == NODE_ISCS {
		return self.compile_iscs(node)
	} else if node.type_ == NODE_ISNOT {
		return self.compile_isnot(node)
	} else if node.type_ == NODE_ISNOTCI {
		return self.compile_isnotci(node)
	} else if node.type_ == NODE_ISNOTCS {
		return self.compile_isnotcs(node)
	} else if node.type_ == NODE_ADD {
		return self.compile_add(node)
	} else if node.type_ == NODE_SUBTRACT {
		return self.compile_subtract(node)
	} else if node.type_ == NODE_CONCAT {
		return self.compile_concat(node)
	} else if node.type_ == NODE_MULTIPLY {
		return self.compile_multiply(node)
	} else if node.type_ == NODE_DIVIDE {
		return self.compile_divide(node)
	} else if node.type_ == NODE_REMAINDER {
		return self.compile_remainder(node)
	} else if node.type_ == NODE_NOT {
		return self.compile_not(node)
	} else if node.type_ == NODE_PLUS {
		return self.compile_plus(node)
	} else if node.type_ == NODE_MINUS {
		return self.compile_minus(node)
	} else if node.type_ == NODE_SUBSCRIPT {
		return self.compile_subscript(node)
	} else if node.type_ == NODE_SLICE {
		return self.compile_slice(node)
	} else if node.type_ == NODE_DOT {
		return self.compile_dot(node)
	} else if node.type_ == NODE_CALL {
		return self.compile_call(node)
	} else if node.type_ == NODE_NUMBER {
		return self.compile_number(node)
	} else if node.type_ == NODE_STRING {
		return self.compile_string(node)
	} else if node.type_ == NODE_LIST {
		return self.compile_list(node)
	} else if node.type_ == NODE_DICT {
		return self.compile_dict(node)
	} else if node.type_ == NODE_OPTION {
		return self.compile_option(node)
	} else if node.type_ == NODE_IDENTIFIER {
		return self.compile_identifier(node)
	} else if node.type_ == NODE_CURLYNAME {
		return self.compile_curlyname(node)
	} else if node.type_ == NODE_ENV {
		return self.compile_env(node)
	} else if node.type_ == NODE_REG {
		return self.compile_reg(node)
	} else if node.type_ == NODE_CURLYNAMEPART {
		return self.compile_curlynamepart(node)
	} else if node.type_ == NODE_CURLYNAMEEXPR {
		return self.compile_curlynameexpr(node)
	} else if node.type_ == NODE_LAMBDA {
		return self.compile_lambda(node)
	} else if node.type_ == NODE_PARENEXPR {
		return self.compile_parenexpr(node)
	} else {
		panic(viml_printf("Compiler: unknown node: %s", viml_string(node)))
	}
	return nil
}

func (self *Compiler) compile_body(body []*VimNode) {
	for _, node := range body {
		self.compile(node)
	}
}

func (self *Compiler) compile_toplevel(node *VimNode) []string {
	self.compile_body(node.body)
	return self.lines
}

func (self *Compiler) compile_comment(node *VimNode) {
	self.out(";%s", node.str)
}

func (self *Compiler) compile_excmd(node *VimNode) {
	self.out("(excmd \"%s\")", viml_escape(node.str, "\\\""))
}

func (self *Compiler) compile_function(node *VimNode) {
	var left = self.compile(node.left).(string)
	var rlist = func() []string {
		var ss []string
		for _, vval := range node.rlist {
			ss = append(ss, self.compile(vval).(string))
		}
		return ss
	}()
	if !viml_empty(rlist) && rlist[len(rlist)-1] == "..." {
		rlist[len(rlist)-1] = ". ..."
	}
	if viml_empty(rlist) {
		self.out("(function (%s)", left)
	} else {
		self.out("(function (%s %s)", left, viml_join(rlist, " "))
	}
	self.incindent("  ")
	self.compile_body(node.body)
	self.out(")")
	self.decindent()
}

func (self *Compiler) compile_delfunction(node *VimNode) {
	self.out("(delfunction %s)", self.compile(node.left).(string))
}

func (self *Compiler) compile_return(node *VimNode) {
	if node.left == nil {
		self.out("(return)")
	} else {
		self.out("(return %s)", self.compile(node.left).(string))
	}
}

func (self *Compiler) compile_excall(node *VimNode) {
	self.out("(call %s)", self.compile(node.left).(string))
}

func (self *Compiler) compile_let(node *VimNode) {
	var left = ""
	if node.left != nil {
		left = self.compile(node.left).(string)
	} else {
		left = viml_join(func() []string {
			var ss []string
			for _, vval := range node.list {
				ss = append(ss, self.compile(vval).(string))
			}
			return ss
		}(), " ")
		if node.rest != nil {
			left += " . " + self.compile(node.rest).(string)
		}
		left = "(" + left + ")"
	}
	var right = self.compile(node.right)
	self.out("(let %s %s %s)", node.op, left, right)
}

func (self *Compiler) compile_unlet(node *VimNode) {
	var list = func() []string {
		var ss []string
		for _, vval := range node.list {
			ss = append(ss, self.compile(vval).(string))
		}
		return ss
	}()
	self.out("(unlet %s)", viml_join(list, " "))
}

func (self *Compiler) compile_lockvar(node *VimNode) {
	var list = func() []string {
		var ss []string
		for _, vval := range node.list {
			ss = append(ss, self.compile(vval).(string))
		}
		return ss
	}()
	if node.depth == 0 {
		self.out("(lockvar %s)", viml_join(list, " "))
	} else {
		self.out("(lockvar %d %s)", node.depth, viml_join(list, " "))
	}
}

func (self *Compiler) compile_unlockvar(node *VimNode) {
	var list = func() []string {
		var ss []string
		for _, vval := range node.list {
			ss = append(ss, self.compile(vval).(string))
		}
		return ss
	}()
	if node.depth == 0 {
		self.out("(unlockvar %s)", viml_join(list, " "))
	} else {
		self.out("(unlockvar %d %s)", node.depth, viml_join(list, " "))
	}
}

func (self *Compiler) compile_if(node *VimNode) {
	self.out("(if %s", self.compile(node.cond))
	self.incindent("  ")
	self.compile_body(node.body)
	self.decindent()
	for _, enode := range node.elseif {
		self.out(" elseif %s", self.compile(enode.cond))
		self.incindent("  ")
		self.compile_body(enode.body)
		self.decindent()
	}
	if node.else_ != nil {
		self.out(" else")
		self.incindent("  ")
		self.compile_body(node.else_.body)
		self.decindent()
	}
	self.incindent("  ")
	self.out(")")
	self.decindent()
}

func (self *Compiler) compile_while(node *VimNode) {
	self.out("(while %s", self.compile(node.cond))
	self.incindent("  ")
	self.compile_body(node.body)
	self.out(")")
	self.decindent()
}

func (self *Compiler) compile_for(node *VimNode) {
	var left = ""
	if node.left != nil {
		left = self.compile(node.left).(string)
	} else {
		left = viml_join(func() []string {
			var ss []string
			for _, vval := range node.list {
				ss = append(ss, self.compile(vval).(string))
			}
			return ss
		}(), " ")
		if node.rest != nil {
			left += " . " + self.compile(node.rest).(string)
		}
		left = "(" + left + ")"
	}
	var right = self.compile(node.right)
	self.out("(for %s %s", left, right)
	self.incindent("  ")
	self.compile_body(node.body)
	self.out(")")
	self.decindent()
}

func (self *Compiler) compile_continue(node *VimNode) {
	self.out("(continue)")
}

func (self *Compiler) compile_break(node *VimNode) {
	self.out("(break)")
}

func (self *Compiler) compile_try(node *VimNode) {
	self.out("(try")
	self.incindent("  ")
	self.compile_body(node.body)
	for _, cnode := range node.catch {
		if cnode.pattern != "" {
			self.decindent()
			self.out(" catch /%s/", cnode.pattern)
			self.incindent("  ")
			self.compile_body(cnode.body)
		} else {
			self.decindent()
			self.out(" catch")
			self.incindent("  ")
			self.compile_body(cnode.body)
		}
	}
	if node.finally != nil {
		self.decindent()
		self.out(" finally")
		self.incindent("  ")
		self.compile_body(node.finally.body)
	}
	self.out(")")
	self.decindent()
}

func (self *Compiler) compile_throw(node *VimNode) {
	self.out("(throw %s)", self.compile(node.left).(string))
}

func (self *Compiler) compile_echo(node *VimNode) {
	var list = func() []string {
		var ss []string
		for _, vval := range node.list {
			ss = append(ss, self.compile(vval).(string))
		}
		return ss
	}()
	self.out("(echo %s)", viml_join(list, " "))
}

func (self *Compiler) compile_echon(node *VimNode) {
	var list = func() []string {
		var ss []string
		for _, vval := range node.list {
			ss = append(ss, self.compile(vval).(string))
		}
		return ss
	}()
	self.out("(echon %s)", viml_join(list, " "))
}

func (self *Compiler) compile_echohl(node *VimNode) {
	self.out("(echohl \"%s\")", viml_escape(node.str, "\\\""))
}

func (self *Compiler) compile_echomsg(node *VimNode) {
	var list = func() []string {
		var ss []string
		for _, vval := range node.list {
			ss = append(ss, self.compile(vval).(string))
		}
		return ss
	}()
	self.out("(echomsg %s)", viml_join(list, " "))
}

func (self *Compiler) compile_echoerr(node *VimNode) {
	var list = func() []string {
		var ss []string
		for _, vval := range node.list {
			ss = append(ss, self.compile(vval).(string))
		}
		return ss
	}()
	self.out("(echoerr %s)", viml_join(list, " "))
}

func (self *Compiler) compile_execute(node *VimNode) {
	var list = func() []string {
		var ss []string
		for _, vval := range node.list {
			ss = append(ss, self.compile(vval).(string))
		}
		return ss
	}()
	self.out("(execute %s)", viml_join(list, " "))
}

func (self *Compiler) compile_ternary(node *VimNode) string {
	return viml_printf("(?: %s %s %s)", self.compile(node.cond), self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_or(node *VimNode) string {
	return viml_printf("(|| %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_and(node *VimNode) string {
	return viml_printf("(&& %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_equal(node *VimNode) string {
	return viml_printf("(== %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_equalci(node *VimNode) string {
	return viml_printf("(==? %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_equalcs(node *VimNode) string {
	return viml_printf("(==# %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_nequal(node *VimNode) string {
	return viml_printf("(!= %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_nequalci(node *VimNode) string {
	return viml_printf("(!=? %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_nequalcs(node *VimNode) string {
	return viml_printf("(!=# %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_greater(node *VimNode) string {
	return viml_printf("(> %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_greaterci(node *VimNode) string {
	return viml_printf("(>? %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_greatercs(node *VimNode) string {
	return viml_printf("(># %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_gequal(node *VimNode) string {
	return viml_printf("(>= %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_gequalci(node *VimNode) string {
	return viml_printf("(>=? %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_gequalcs(node *VimNode) string {
	return viml_printf("(>=# %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_smaller(node *VimNode) string {
	return viml_printf("(< %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_smallerci(node *VimNode) string {
	return viml_printf("(<? %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_smallercs(node *VimNode) string {
	return viml_printf("(<# %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_sequal(node *VimNode) string {
	return viml_printf("(<= %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_sequalci(node *VimNode) string {
	return viml_printf("(<=? %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_sequalcs(node *VimNode) string {
	return viml_printf("(<=# %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_match(node *VimNode) string {
	return viml_printf("(=~ %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_matchci(node *VimNode) string {
	return viml_printf("(=~? %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_matchcs(node *VimNode) string {
	return viml_printf("(=~# %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_nomatch(node *VimNode) string {
	return viml_printf("(!~ %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_nomatchci(node *VimNode) string {
	return viml_printf("(!~? %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_nomatchcs(node *VimNode) string {
	return viml_printf("(!~# %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_is(node *VimNode) string {
	return viml_printf("(is %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_isci(node *VimNode) string {
	return viml_printf("(is? %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_iscs(node *VimNode) string {
	return viml_printf("(is# %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_isnot(node *VimNode) string {
	return viml_printf("(isnot %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_isnotci(node *VimNode) string {
	return viml_printf("(isnot? %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_isnotcs(node *VimNode) string {
	return viml_printf("(isnot# %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_add(node *VimNode) string {
	return viml_printf("(+ %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_subtract(node *VimNode) string {
	return viml_printf("(- %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_concat(node *VimNode) string {
	return viml_printf("(concat %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_multiply(node *VimNode) string {
	return viml_printf("(* %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_divide(node *VimNode) string {
	return viml_printf("(/ %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_remainder(node *VimNode) string {
	return viml_printf("(%% %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_not(node *VimNode) string {
	return viml_printf("(! %s)", self.compile(node.left).(string))
}

func (self *Compiler) compile_plus(node *VimNode) string {
	return viml_printf("(+ %s)", self.compile(node.left).(string))
}

func (self *Compiler) compile_minus(node *VimNode) string {
	return viml_printf("(- %s)", self.compile(node.left).(string))
}

func (self *Compiler) compile_subscript(node *VimNode) string {
	return viml_printf("(subscript %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_slice(node *VimNode) string {
	var r0 = func() string {
		if node.rlist[0] == nil {
			return "nil"
		} else {
			return self.compile(node.rlist[0]).(string)
		}
	}()
	var r1 = func() string {
		if node.rlist[1] == nil {
			return "nil"
		} else {
			return self.compile(node.rlist[1]).(string)
		}
	}()
	return viml_printf("(slice %s %s %s)", self.compile(node.left).(string), r0, r1)
}

func (self *Compiler) compile_dot(node *VimNode) string {
	return viml_printf("(dot %s %s)", self.compile(node.left).(string), self.compile(node.right))
}

func (self *Compiler) compile_call(node *VimNode) string {
	var rlist = func() []string {
		var ss []string
		for _, vval := range node.rlist {
			ss = append(ss, self.compile(vval).(string))
		}
		return ss
	}()
	if viml_empty(rlist) {
		return viml_printf("(%s)", self.compile(node.left).(string))
	} else {
		return viml_printf("(%s %s)", self.compile(node.left).(string), viml_join(rlist, " "))
	}
}

func (self *Compiler) compile_number(node *VimNode) string {
	return node.value.(string)
}

func (self *Compiler) compile_string(node *VimNode) string {
	return node.value.(string)
}

func (self *Compiler) compile_option(node *VimNode) string {
	return node.value.(string)
}

func (self *Compiler) compile_identifier(node *VimNode) string {
	return node.value.(string)
}

func (self *Compiler) compile_env(node *VimNode) string {
	return node.value.(string)
}

func (self *Compiler) compile_reg(node *VimNode) string {
	return node.value.(string)
}

func (self *Compiler) compile_curlynamepart(node *VimNode) string {
	return node.value.(string)
}

func (self *Compiler) compile_lambda(node *VimNode) string {
	var rlist = func() []string {
		var ss []string
		for _, vval := range node.rlist {
			ss = append(ss, self.compile(vval).(string))
		}
		return ss
	}()
	return viml_printf("(lambda (%s) %s)", viml_join(rlist, " "), self.compile(node.left).(string))
}

// TODO: under construction
